// Code generated by protoc-gen-go. DO NOT EDIT.
// source: worker.proto

package sonm

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// grpccmd imports
import (
	"io"

	"github.com/spf13/cobra"
	"github.com/sshaman1101/grpccmd"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type TaskStatusReply_Status int32

const (
	TaskStatusReply_UNKNOWN  TaskStatusReply_Status = 0
	TaskStatusReply_SPOOLING TaskStatusReply_Status = 1
	TaskStatusReply_SPAWNING TaskStatusReply_Status = 2
	TaskStatusReply_RUNNING  TaskStatusReply_Status = 3
	TaskStatusReply_FINISHED TaskStatusReply_Status = 4
	TaskStatusReply_BROKEN   TaskStatusReply_Status = 5
)

var TaskStatusReply_Status_name = map[int32]string{
	0: "UNKNOWN",
	1: "SPOOLING",
	2: "SPAWNING",
	3: "RUNNING",
	4: "FINISHED",
	5: "BROKEN",
}
var TaskStatusReply_Status_value = map[string]int32{
	"UNKNOWN":  0,
	"SPOOLING": 1,
	"SPAWNING": 2,
	"RUNNING":  3,
	"FINISHED": 4,
	"BROKEN":   5,
}

func (x TaskStatusReply_Status) String() string {
	return proto.EnumName(TaskStatusReply_Status_name, int32(x))
}
func (TaskStatusReply_Status) EnumDescriptor() ([]byte, []int) { return fileDescriptor14, []int{11, 0} }

type TaskTag struct {
	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *TaskTag) Reset()                    { *m = TaskTag{} }
func (m *TaskTag) String() string            { return proto.CompactTextString(m) }
func (*TaskTag) ProtoMessage()               {}
func (*TaskTag) Descriptor() ([]byte, []int) { return fileDescriptor14, []int{0} }

func (m *TaskTag) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type TaskSpec struct {
	// Container describes container settings.
	Container *Container        `protobuf:"bytes,1,opt,name=container" json:"container,omitempty"`
	Registry  *Registry         `protobuf:"bytes,2,opt,name=registry" json:"registry,omitempty"`
	Resources *AskPlanResources `protobuf:"bytes,3,opt,name=resources" json:"resources,omitempty"`
	Tag       *TaskTag          `protobuf:"bytes,4,opt,name=tag" json:"tag,omitempty"`
}

func (m *TaskSpec) Reset()                    { *m = TaskSpec{} }
func (m *TaskSpec) String() string            { return proto.CompactTextString(m) }
func (*TaskSpec) ProtoMessage()               {}
func (*TaskSpec) Descriptor() ([]byte, []int) { return fileDescriptor14, []int{1} }

func (m *TaskSpec) GetContainer() *Container {
	if m != nil {
		return m.Container
	}
	return nil
}

func (m *TaskSpec) GetRegistry() *Registry {
	if m != nil {
		return m.Registry
	}
	return nil
}

func (m *TaskSpec) GetResources() *AskPlanResources {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *TaskSpec) GetTag() *TaskTag {
	if m != nil {
		return m.Tag
	}
	return nil
}

type StartTaskRequest struct {
	// Deal points to the deal associated with workers where the task should be
	// started.
	DealID *BigInt   `protobuf:"bytes,1,opt,name=dealID" json:"dealID,omitempty"`
	Spec   *TaskSpec `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
}

func (m *StartTaskRequest) Reset()                    { *m = StartTaskRequest{} }
func (m *StartTaskRequest) String() string            { return proto.CompactTextString(m) }
func (*StartTaskRequest) ProtoMessage()               {}
func (*StartTaskRequest) Descriptor() ([]byte, []int) { return fileDescriptor14, []int{2} }

func (m *StartTaskRequest) GetDealID() *BigInt {
	if m != nil {
		return m.DealID
	}
	return nil
}

func (m *StartTaskRequest) GetSpec() *TaskSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

type WorkerJoinNetworkRequest struct {
	TaskID    string `protobuf:"bytes,1,opt,name=taskID" json:"taskID,omitempty"`
	NetworkID string `protobuf:"bytes,2,opt,name=networkID" json:"networkID,omitempty"`
}

func (m *WorkerJoinNetworkRequest) Reset()                    { *m = WorkerJoinNetworkRequest{} }
func (m *WorkerJoinNetworkRequest) String() string            { return proto.CompactTextString(m) }
func (*WorkerJoinNetworkRequest) ProtoMessage()               {}
func (*WorkerJoinNetworkRequest) Descriptor() ([]byte, []int) { return fileDescriptor14, []int{3} }

func (m *WorkerJoinNetworkRequest) GetTaskID() string {
	if m != nil {
		return m.TaskID
	}
	return ""
}

func (m *WorkerJoinNetworkRequest) GetNetworkID() string {
	if m != nil {
		return m.NetworkID
	}
	return ""
}

type StartTaskReply struct {
	Id         string                `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	PortMap    map[string]*Endpoints `protobuf:"bytes,2,rep,name=portMap" json:"portMap,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	NetworkIDs []string              `protobuf:"bytes,3,rep,name=networkIDs" json:"networkIDs,omitempty"`
}

func (m *StartTaskReply) Reset()                    { *m = StartTaskReply{} }
func (m *StartTaskReply) String() string            { return proto.CompactTextString(m) }
func (*StartTaskReply) ProtoMessage()               {}
func (*StartTaskReply) Descriptor() ([]byte, []int) { return fileDescriptor14, []int{4} }

func (m *StartTaskReply) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *StartTaskReply) GetPortMap() map[string]*Endpoints {
	if m != nil {
		return m.PortMap
	}
	return nil
}

func (m *StartTaskReply) GetNetworkIDs() []string {
	if m != nil {
		return m.NetworkIDs
	}
	return nil
}

type StatusReply struct {
	Uptime           uint64 `protobuf:"varint,1,opt,name=uptime" json:"uptime,omitempty"`
	Version          string `protobuf:"bytes,2,opt,name=version" json:"version,omitempty"`
	Platform         string `protobuf:"bytes,3,opt,name=platform" json:"platform,omitempty"`
	EthAddr          string `protobuf:"bytes,4,opt,name=ethAddr" json:"ethAddr,omitempty"`
	TaskCount        uint32 `protobuf:"varint,5,opt,name=taskCount" json:"taskCount,omitempty"`
	DWHStatus        string `protobuf:"bytes,6,opt,name=DWHStatus" json:"DWHStatus,omitempty"`
	RendezvousStatus string `protobuf:"bytes,7,opt,name=rendezvousStatus" json:"rendezvousStatus,omitempty"`
}

func (m *StatusReply) Reset()                    { *m = StatusReply{} }
func (m *StatusReply) String() string            { return proto.CompactTextString(m) }
func (*StatusReply) ProtoMessage()               {}
func (*StatusReply) Descriptor() ([]byte, []int) { return fileDescriptor14, []int{5} }

func (m *StatusReply) GetUptime() uint64 {
	if m != nil {
		return m.Uptime
	}
	return 0
}

func (m *StatusReply) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *StatusReply) GetPlatform() string {
	if m != nil {
		return m.Platform
	}
	return ""
}

func (m *StatusReply) GetEthAddr() string {
	if m != nil {
		return m.EthAddr
	}
	return ""
}

func (m *StatusReply) GetTaskCount() uint32 {
	if m != nil {
		return m.TaskCount
	}
	return 0
}

func (m *StatusReply) GetDWHStatus() string {
	if m != nil {
		return m.DWHStatus
	}
	return ""
}

func (m *StatusReply) GetRendezvousStatus() string {
	if m != nil {
		return m.RendezvousStatus
	}
	return ""
}

type AskPlansReply struct {
	AskPlans map[string]*AskPlan `protobuf:"bytes,1,rep,name=askPlans" json:"askPlans,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *AskPlansReply) Reset()                    { *m = AskPlansReply{} }
func (m *AskPlansReply) String() string            { return proto.CompactTextString(m) }
func (*AskPlansReply) ProtoMessage()               {}
func (*AskPlansReply) Descriptor() ([]byte, []int) { return fileDescriptor14, []int{6} }

func (m *AskPlansReply) GetAskPlans() map[string]*AskPlan {
	if m != nil {
		return m.AskPlans
	}
	return nil
}

type TaskListReply struct {
	Info map[string]*TaskStatusReply `protobuf:"bytes,1,rep,name=info" json:"info,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *TaskListReply) Reset()                    { *m = TaskListReply{} }
func (m *TaskListReply) String() string            { return proto.CompactTextString(m) }
func (*TaskListReply) ProtoMessage()               {}
func (*TaskListReply) Descriptor() ([]byte, []int) { return fileDescriptor14, []int{7} }

func (m *TaskListReply) GetInfo() map[string]*TaskStatusReply {
	if m != nil {
		return m.Info
	}
	return nil
}

type DevicesReply struct {
	CPU     *CPU     `protobuf:"bytes,1,opt,name=CPU" json:"CPU,omitempty"`
	GPUs    []*GPU   `protobuf:"bytes,2,rep,name=GPUs" json:"GPUs,omitempty"`
	RAM     *RAM     `protobuf:"bytes,3,opt,name=RAM" json:"RAM,omitempty"`
	Network *Network `protobuf:"bytes,4,opt,name=network" json:"network,omitempty"`
	Storage *Storage `protobuf:"bytes,5,opt,name=storage" json:"storage,omitempty"`
}

func (m *DevicesReply) Reset()                    { *m = DevicesReply{} }
func (m *DevicesReply) String() string            { return proto.CompactTextString(m) }
func (*DevicesReply) ProtoMessage()               {}
func (*DevicesReply) Descriptor() ([]byte, []int) { return fileDescriptor14, []int{8} }

func (m *DevicesReply) GetCPU() *CPU {
	if m != nil {
		return m.CPU
	}
	return nil
}

func (m *DevicesReply) GetGPUs() []*GPU {
	if m != nil {
		return m.GPUs
	}
	return nil
}

func (m *DevicesReply) GetRAM() *RAM {
	if m != nil {
		return m.RAM
	}
	return nil
}

func (m *DevicesReply) GetNetwork() *Network {
	if m != nil {
		return m.Network
	}
	return nil
}

func (m *DevicesReply) GetStorage() *Storage {
	if m != nil {
		return m.Storage
	}
	return nil
}

type PullTaskRequest struct {
	DealId string `protobuf:"bytes,1,opt,name=dealId" json:"dealId,omitempty"`
	TaskId string `protobuf:"bytes,2,opt,name=taskId" json:"taskId,omitempty"`
}

func (m *PullTaskRequest) Reset()                    { *m = PullTaskRequest{} }
func (m *PullTaskRequest) String() string            { return proto.CompactTextString(m) }
func (*PullTaskRequest) ProtoMessage()               {}
func (*PullTaskRequest) Descriptor() ([]byte, []int) { return fileDescriptor14, []int{9} }

func (m *PullTaskRequest) GetDealId() string {
	if m != nil {
		return m.DealId
	}
	return ""
}

func (m *PullTaskRequest) GetTaskId() string {
	if m != nil {
		return m.TaskId
	}
	return ""
}

type DealInfoReply struct {
	Deal *Deal `protobuf:"bytes,1,opt,name=deal" json:"deal,omitempty"`
	// List of currently running tasks.
	Running map[string]*TaskStatusReply `protobuf:"bytes,2,rep,name=running" json:"running,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// List of completed tasks.
	Completed map[string]*TaskStatusReply `protobuf:"bytes,3,rep,name=completed" json:"completed,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Resources is a real resources (cores, ram bytes, GPU devices, etc)
	// allocated on a worker for this deal.
	Resources *AskPlanResources `protobuf:"bytes,4,opt,name=resources" json:"resources,omitempty"`
}

func (m *DealInfoReply) Reset()                    { *m = DealInfoReply{} }
func (m *DealInfoReply) String() string            { return proto.CompactTextString(m) }
func (*DealInfoReply) ProtoMessage()               {}
func (*DealInfoReply) Descriptor() ([]byte, []int) { return fileDescriptor14, []int{10} }

func (m *DealInfoReply) GetDeal() *Deal {
	if m != nil {
		return m.Deal
	}
	return nil
}

func (m *DealInfoReply) GetRunning() map[string]*TaskStatusReply {
	if m != nil {
		return m.Running
	}
	return nil
}

func (m *DealInfoReply) GetCompleted() map[string]*TaskStatusReply {
	if m != nil {
		return m.Completed
	}
	return nil
}

func (m *DealInfoReply) GetResources() *AskPlanResources {
	if m != nil {
		return m.Resources
	}
	return nil
}

type TaskStatusReply struct {
	Status    TaskStatusReply_Status `protobuf:"varint,1,opt,name=status,enum=sonm.TaskStatusReply_Status" json:"status,omitempty"`
	ImageName string                 `protobuf:"bytes,2,opt,name=imageName" json:"imageName,omitempty"`
	PortMap   map[string]*Endpoints  `protobuf:"bytes,3,rep,name=portMap" json:"portMap,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Uptime    uint64                 `protobuf:"varint,4,opt,name=uptime" json:"uptime,omitempty"`
	Usage     *ResourceUsage         `protobuf:"bytes,5,opt,name=usage" json:"usage,omitempty"`
	// TODO: looks like we need to use TaskSpec here
	AllocatedResources *AskPlanResources `protobuf:"bytes,6,opt,name=allocatedResources" json:"allocatedResources,omitempty"`
	Tag                *TaskTag          `protobuf:"bytes,7,opt,name=tag" json:"tag,omitempty"`
}

func (m *TaskStatusReply) Reset()                    { *m = TaskStatusReply{} }
func (m *TaskStatusReply) String() string            { return proto.CompactTextString(m) }
func (*TaskStatusReply) ProtoMessage()               {}
func (*TaskStatusReply) Descriptor() ([]byte, []int) { return fileDescriptor14, []int{11} }

func (m *TaskStatusReply) GetStatus() TaskStatusReply_Status {
	if m != nil {
		return m.Status
	}
	return TaskStatusReply_UNKNOWN
}

func (m *TaskStatusReply) GetImageName() string {
	if m != nil {
		return m.ImageName
	}
	return ""
}

func (m *TaskStatusReply) GetPortMap() map[string]*Endpoints {
	if m != nil {
		return m.PortMap
	}
	return nil
}

func (m *TaskStatusReply) GetUptime() uint64 {
	if m != nil {
		return m.Uptime
	}
	return 0
}

func (m *TaskStatusReply) GetUsage() *ResourceUsage {
	if m != nil {
		return m.Usage
	}
	return nil
}

func (m *TaskStatusReply) GetAllocatedResources() *AskPlanResources {
	if m != nil {
		return m.AllocatedResources
	}
	return nil
}

func (m *TaskStatusReply) GetTag() *TaskTag {
	if m != nil {
		return m.Tag
	}
	return nil
}

type ResourcePool struct {
	All  *AskPlanResources            `protobuf:"bytes,1,opt,name=all" json:"all,omitempty"`
	Used map[string]*AskPlanResources `protobuf:"bytes,2,rep,name=used" json:"used,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *ResourcePool) Reset()                    { *m = ResourcePool{} }
func (m *ResourcePool) String() string            { return proto.CompactTextString(m) }
func (*ResourcePool) ProtoMessage()               {}
func (*ResourcePool) Descriptor() ([]byte, []int) { return fileDescriptor14, []int{12} }

func (m *ResourcePool) GetAll() *AskPlanResources {
	if m != nil {
		return m.All
	}
	return nil
}

func (m *ResourcePool) GetUsed() map[string]*AskPlanResources {
	if m != nil {
		return m.Used
	}
	return nil
}

type SchedulerData struct {
	TaskToAskPlan map[string]string        `protobuf:"bytes,1,rep,name=taskToAskPlan" json:"taskToAskPlan,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	MainPool      *ResourcePool            `protobuf:"bytes,2,opt,name=mainPool" json:"mainPool,omitempty"`
	AskPlanPools  map[string]*ResourcePool `protobuf:"bytes,3,rep,name=askPlanPools" json:"askPlanPools,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *SchedulerData) Reset()                    { *m = SchedulerData{} }
func (m *SchedulerData) String() string            { return proto.CompactTextString(m) }
func (*SchedulerData) ProtoMessage()               {}
func (*SchedulerData) Descriptor() ([]byte, []int) { return fileDescriptor14, []int{13} }

func (m *SchedulerData) GetTaskToAskPlan() map[string]string {
	if m != nil {
		return m.TaskToAskPlan
	}
	return nil
}

func (m *SchedulerData) GetMainPool() *ResourcePool {
	if m != nil {
		return m.MainPool
	}
	return nil
}

func (m *SchedulerData) GetAskPlanPools() map[string]*ResourcePool {
	if m != nil {
		return m.AskPlanPools
	}
	return nil
}

type SalesmanData struct {
	AskPlanCGroups map[string]string `protobuf:"bytes,2,rep,name=askPlanCGroups" json:"askPlanCGroups,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Deals          map[string]*Deal  `protobuf:"bytes,3,rep,name=deals" json:"deals,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Orders         map[string]*Order `protobuf:"bytes,4,rep,name=orders" json:"orders,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *SalesmanData) Reset()                    { *m = SalesmanData{} }
func (m *SalesmanData) String() string            { return proto.CompactTextString(m) }
func (*SalesmanData) ProtoMessage()               {}
func (*SalesmanData) Descriptor() ([]byte, []int) { return fileDescriptor14, []int{14} }

func (m *SalesmanData) GetAskPlanCGroups() map[string]string {
	if m != nil {
		return m.AskPlanCGroups
	}
	return nil
}

func (m *SalesmanData) GetDeals() map[string]*Deal {
	if m != nil {
		return m.Deals
	}
	return nil
}

func (m *SalesmanData) GetOrders() map[string]*Order {
	if m != nil {
		return m.Orders
	}
	return nil
}

type DebugStateReply struct {
	SchedulerData *SchedulerData `protobuf:"bytes,1,opt,name=schedulerData" json:"schedulerData,omitempty"`
	SalesmanData  *SalesmanData  `protobuf:"bytes,2,opt,name=salesmanData" json:"salesmanData,omitempty"`
}

func (m *DebugStateReply) Reset()                    { *m = DebugStateReply{} }
func (m *DebugStateReply) String() string            { return proto.CompactTextString(m) }
func (*DebugStateReply) ProtoMessage()               {}
func (*DebugStateReply) Descriptor() ([]byte, []int) { return fileDescriptor14, []int{15} }

func (m *DebugStateReply) GetSchedulerData() *SchedulerData {
	if m != nil {
		return m.SchedulerData
	}
	return nil
}

func (m *DebugStateReply) GetSalesmanData() *SalesmanData {
	if m != nil {
		return m.SalesmanData
	}
	return nil
}

func init() {
	proto.RegisterType((*TaskTag)(nil), "sonm.TaskTag")
	proto.RegisterType((*TaskSpec)(nil), "sonm.TaskSpec")
	proto.RegisterType((*StartTaskRequest)(nil), "sonm.StartTaskRequest")
	proto.RegisterType((*WorkerJoinNetworkRequest)(nil), "sonm.WorkerJoinNetworkRequest")
	proto.RegisterType((*StartTaskReply)(nil), "sonm.StartTaskReply")
	proto.RegisterType((*StatusReply)(nil), "sonm.StatusReply")
	proto.RegisterType((*AskPlansReply)(nil), "sonm.AskPlansReply")
	proto.RegisterType((*TaskListReply)(nil), "sonm.TaskListReply")
	proto.RegisterType((*DevicesReply)(nil), "sonm.DevicesReply")
	proto.RegisterType((*PullTaskRequest)(nil), "sonm.PullTaskRequest")
	proto.RegisterType((*DealInfoReply)(nil), "sonm.DealInfoReply")
	proto.RegisterType((*TaskStatusReply)(nil), "sonm.TaskStatusReply")
	proto.RegisterType((*ResourcePool)(nil), "sonm.ResourcePool")
	proto.RegisterType((*SchedulerData)(nil), "sonm.SchedulerData")
	proto.RegisterType((*SalesmanData)(nil), "sonm.SalesmanData")
	proto.RegisterType((*DebugStateReply)(nil), "sonm.DebugStateReply")
	proto.RegisterEnum("sonm.TaskStatusReply_Status", TaskStatusReply_Status_name, TaskStatusReply_Status_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for WorkerManagement service

type WorkerManagementClient interface {
	// Status produse a detailed info about worker
	Status(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*StatusReply, error)
	// Devices provides detailed information about device
	// and show benchmark results.
	Devices(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*DevicesReply, error)
	// FreeDevices provides information about unallocated resources
	// that can be turned into ask-plans.
	FreeDevices(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*DevicesReply, error)
	// Tasks produces a list of all running tasks on the worker
	Tasks(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*TaskListReply, error)
	// AskPlans allows to obtain previously assigned Ask Plans from for a given worker.
	AskPlans(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*AskPlansReply, error)
	// CreateAskPlan allows to create rules
	// for creating Ask orders on Marketplace
	CreateAskPlan(ctx context.Context, in *AskPlan, opts ...grpc.CallOption) (*ID, error)
	// RemoveAskPlan allows to remove rules
	// for creating Ask orders on Marketplace
	RemoveAskPlan(ctx context.Context, in *ID, opts ...grpc.CallOption) (*Empty, error)
	// PurgeAskPlans removes all ask-plans
	PurgeAskPlans(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	// Schedule maintenance for worker: it will attempt to close all deals till that time point
	ScheduleMaintenance(ctx context.Context, in *Timestamp, opts ...grpc.CallOption) (*Empty, error)
	// Get next planned maintenance
	NextMaintenance(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Timestamp, error)
	// Get useful debugging info - scheduler state and salesman state
	DebugState(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*DebugStateReply, error)
	// Remove benchmark cached value by specified benchmark ID
	RemoveBenchmark(ctx context.Context, in *NumericID, opts ...grpc.CallOption) (*Empty, error)
	// Schedule full rebenchmarking on next restart
	PurgeBenchmarks(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
}

type workerManagementClient struct {
	cc *grpc.ClientConn
}

func NewWorkerManagementClient(cc *grpc.ClientConn) WorkerManagementClient {
	return &workerManagementClient{cc}
}

func (c *workerManagementClient) Status(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*StatusReply, error) {
	out := new(StatusReply)
	err := grpc.Invoke(ctx, "/sonm.WorkerManagement/Status", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerManagementClient) Devices(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*DevicesReply, error) {
	out := new(DevicesReply)
	err := grpc.Invoke(ctx, "/sonm.WorkerManagement/Devices", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerManagementClient) FreeDevices(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*DevicesReply, error) {
	out := new(DevicesReply)
	err := grpc.Invoke(ctx, "/sonm.WorkerManagement/FreeDevices", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerManagementClient) Tasks(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*TaskListReply, error) {
	out := new(TaskListReply)
	err := grpc.Invoke(ctx, "/sonm.WorkerManagement/Tasks", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerManagementClient) AskPlans(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*AskPlansReply, error) {
	out := new(AskPlansReply)
	err := grpc.Invoke(ctx, "/sonm.WorkerManagement/AskPlans", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerManagementClient) CreateAskPlan(ctx context.Context, in *AskPlan, opts ...grpc.CallOption) (*ID, error) {
	out := new(ID)
	err := grpc.Invoke(ctx, "/sonm.WorkerManagement/CreateAskPlan", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerManagementClient) RemoveAskPlan(ctx context.Context, in *ID, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/sonm.WorkerManagement/RemoveAskPlan", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerManagementClient) PurgeAskPlans(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/sonm.WorkerManagement/PurgeAskPlans", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerManagementClient) ScheduleMaintenance(ctx context.Context, in *Timestamp, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/sonm.WorkerManagement/ScheduleMaintenance", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerManagementClient) NextMaintenance(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Timestamp, error) {
	out := new(Timestamp)
	err := grpc.Invoke(ctx, "/sonm.WorkerManagement/NextMaintenance", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerManagementClient) DebugState(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*DebugStateReply, error) {
	out := new(DebugStateReply)
	err := grpc.Invoke(ctx, "/sonm.WorkerManagement/DebugState", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerManagementClient) RemoveBenchmark(ctx context.Context, in *NumericID, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/sonm.WorkerManagement/RemoveBenchmark", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerManagementClient) PurgeBenchmarks(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/sonm.WorkerManagement/PurgeBenchmarks", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for WorkerManagement service

type WorkerManagementServer interface {
	// Status produse a detailed info about worker
	Status(context.Context, *Empty) (*StatusReply, error)
	// Devices provides detailed information about device
	// and show benchmark results.
	Devices(context.Context, *Empty) (*DevicesReply, error)
	// FreeDevices provides information about unallocated resources
	// that can be turned into ask-plans.
	FreeDevices(context.Context, *Empty) (*DevicesReply, error)
	// Tasks produces a list of all running tasks on the worker
	Tasks(context.Context, *Empty) (*TaskListReply, error)
	// AskPlans allows to obtain previously assigned Ask Plans from for a given worker.
	AskPlans(context.Context, *Empty) (*AskPlansReply, error)
	// CreateAskPlan allows to create rules
	// for creating Ask orders on Marketplace
	CreateAskPlan(context.Context, *AskPlan) (*ID, error)
	// RemoveAskPlan allows to remove rules
	// for creating Ask orders on Marketplace
	RemoveAskPlan(context.Context, *ID) (*Empty, error)
	// PurgeAskPlans removes all ask-plans
	PurgeAskPlans(context.Context, *Empty) (*Empty, error)
	// Schedule maintenance for worker: it will attempt to close all deals till that time point
	ScheduleMaintenance(context.Context, *Timestamp) (*Empty, error)
	// Get next planned maintenance
	NextMaintenance(context.Context, *Empty) (*Timestamp, error)
	// Get useful debugging info - scheduler state and salesman state
	DebugState(context.Context, *Empty) (*DebugStateReply, error)
	// Remove benchmark cached value by specified benchmark ID
	RemoveBenchmark(context.Context, *NumericID) (*Empty, error)
	// Schedule full rebenchmarking on next restart
	PurgeBenchmarks(context.Context, *Empty) (*Empty, error)
}

func RegisterWorkerManagementServer(s *grpc.Server, srv WorkerManagementServer) {
	s.RegisterService(&_WorkerManagement_serviceDesc, srv)
}

func _WorkerManagement_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerManagementServer).Status(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.WorkerManagement/Status",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerManagementServer).Status(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerManagement_Devices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerManagementServer).Devices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.WorkerManagement/Devices",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerManagementServer).Devices(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerManagement_FreeDevices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerManagementServer).FreeDevices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.WorkerManagement/FreeDevices",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerManagementServer).FreeDevices(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerManagement_Tasks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerManagementServer).Tasks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.WorkerManagement/Tasks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerManagementServer).Tasks(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerManagement_AskPlans_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerManagementServer).AskPlans(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.WorkerManagement/AskPlans",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerManagementServer).AskPlans(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerManagement_CreateAskPlan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AskPlan)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerManagementServer).CreateAskPlan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.WorkerManagement/CreateAskPlan",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerManagementServer).CreateAskPlan(ctx, req.(*AskPlan))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerManagement_RemoveAskPlan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerManagementServer).RemoveAskPlan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.WorkerManagement/RemoveAskPlan",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerManagementServer).RemoveAskPlan(ctx, req.(*ID))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerManagement_PurgeAskPlans_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerManagementServer).PurgeAskPlans(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.WorkerManagement/PurgeAskPlans",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerManagementServer).PurgeAskPlans(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerManagement_ScheduleMaintenance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Timestamp)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerManagementServer).ScheduleMaintenance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.WorkerManagement/ScheduleMaintenance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerManagementServer).ScheduleMaintenance(ctx, req.(*Timestamp))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerManagement_NextMaintenance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerManagementServer).NextMaintenance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.WorkerManagement/NextMaintenance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerManagementServer).NextMaintenance(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerManagement_DebugState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerManagementServer).DebugState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.WorkerManagement/DebugState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerManagementServer).DebugState(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerManagement_RemoveBenchmark_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NumericID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerManagementServer).RemoveBenchmark(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.WorkerManagement/RemoveBenchmark",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerManagementServer).RemoveBenchmark(ctx, req.(*NumericID))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerManagement_PurgeBenchmarks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerManagementServer).PurgeBenchmarks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.WorkerManagement/PurgeBenchmarks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerManagementServer).PurgeBenchmarks(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _WorkerManagement_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sonm.WorkerManagement",
	HandlerType: (*WorkerManagementServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Status",
			Handler:    _WorkerManagement_Status_Handler,
		},
		{
			MethodName: "Devices",
			Handler:    _WorkerManagement_Devices_Handler,
		},
		{
			MethodName: "FreeDevices",
			Handler:    _WorkerManagement_FreeDevices_Handler,
		},
		{
			MethodName: "Tasks",
			Handler:    _WorkerManagement_Tasks_Handler,
		},
		{
			MethodName: "AskPlans",
			Handler:    _WorkerManagement_AskPlans_Handler,
		},
		{
			MethodName: "CreateAskPlan",
			Handler:    _WorkerManagement_CreateAskPlan_Handler,
		},
		{
			MethodName: "RemoveAskPlan",
			Handler:    _WorkerManagement_RemoveAskPlan_Handler,
		},
		{
			MethodName: "PurgeAskPlans",
			Handler:    _WorkerManagement_PurgeAskPlans_Handler,
		},
		{
			MethodName: "ScheduleMaintenance",
			Handler:    _WorkerManagement_ScheduleMaintenance_Handler,
		},
		{
			MethodName: "NextMaintenance",
			Handler:    _WorkerManagement_NextMaintenance_Handler,
		},
		{
			MethodName: "DebugState",
			Handler:    _WorkerManagement_DebugState_Handler,
		},
		{
			MethodName: "RemoveBenchmark",
			Handler:    _WorkerManagement_RemoveBenchmark_Handler,
		},
		{
			MethodName: "PurgeBenchmarks",
			Handler:    _WorkerManagement_PurgeBenchmarks_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "worker.proto",
}

// Client API for Worker service

type WorkerClient interface {
	PushTask(ctx context.Context, opts ...grpc.CallOption) (Worker_PushTaskClient, error)
	PullTask(ctx context.Context, in *PullTaskRequest, opts ...grpc.CallOption) (Worker_PullTaskClient, error)
	// StartTask schedules the task associcated with a deal.
	StartTask(ctx context.Context, in *StartTaskRequest, opts ...grpc.CallOption) (*StartTaskReply, error)
	StopTask(ctx context.Context, in *ID, opts ...grpc.CallOption) (*Empty, error)
	TaskStatus(ctx context.Context, in *ID, opts ...grpc.CallOption) (*TaskStatusReply, error)
	JoinNetwork(ctx context.Context, in *WorkerJoinNetworkRequest, opts ...grpc.CallOption) (*NetworkSpec, error)
	TaskLogs(ctx context.Context, in *TaskLogsRequest, opts ...grpc.CallOption) (Worker_TaskLogsClient, error)
	// Note: currently used for testing pusposes.
	GetDealInfo(ctx context.Context, in *ID, opts ...grpc.CallOption) (*DealInfoReply, error)
}

type workerClient struct {
	cc *grpc.ClientConn
}

func NewWorkerClient(cc *grpc.ClientConn) WorkerClient {
	return &workerClient{cc}
}

func (c *workerClient) PushTask(ctx context.Context, opts ...grpc.CallOption) (Worker_PushTaskClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Worker_serviceDesc.Streams[0], c.cc, "/sonm.Worker/PushTask", opts...)
	if err != nil {
		return nil, err
	}
	x := &workerPushTaskClient{stream}
	return x, nil
}

type Worker_PushTaskClient interface {
	Send(*Chunk) error
	Recv() (*Progress, error)
	grpc.ClientStream
}

type workerPushTaskClient struct {
	grpc.ClientStream
}

func (x *workerPushTaskClient) Send(m *Chunk) error {
	return x.ClientStream.SendMsg(m)
}

func (x *workerPushTaskClient) Recv() (*Progress, error) {
	m := new(Progress)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *workerClient) PullTask(ctx context.Context, in *PullTaskRequest, opts ...grpc.CallOption) (Worker_PullTaskClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Worker_serviceDesc.Streams[1], c.cc, "/sonm.Worker/PullTask", opts...)
	if err != nil {
		return nil, err
	}
	x := &workerPullTaskClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Worker_PullTaskClient interface {
	Recv() (*Chunk, error)
	grpc.ClientStream
}

type workerPullTaskClient struct {
	grpc.ClientStream
}

func (x *workerPullTaskClient) Recv() (*Chunk, error) {
	m := new(Chunk)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *workerClient) StartTask(ctx context.Context, in *StartTaskRequest, opts ...grpc.CallOption) (*StartTaskReply, error) {
	out := new(StartTaskReply)
	err := grpc.Invoke(ctx, "/sonm.Worker/StartTask", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) StopTask(ctx context.Context, in *ID, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/sonm.Worker/StopTask", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) TaskStatus(ctx context.Context, in *ID, opts ...grpc.CallOption) (*TaskStatusReply, error) {
	out := new(TaskStatusReply)
	err := grpc.Invoke(ctx, "/sonm.Worker/TaskStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) JoinNetwork(ctx context.Context, in *WorkerJoinNetworkRequest, opts ...grpc.CallOption) (*NetworkSpec, error) {
	out := new(NetworkSpec)
	err := grpc.Invoke(ctx, "/sonm.Worker/JoinNetwork", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) TaskLogs(ctx context.Context, in *TaskLogsRequest, opts ...grpc.CallOption) (Worker_TaskLogsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Worker_serviceDesc.Streams[2], c.cc, "/sonm.Worker/TaskLogs", opts...)
	if err != nil {
		return nil, err
	}
	x := &workerTaskLogsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Worker_TaskLogsClient interface {
	Recv() (*TaskLogsChunk, error)
	grpc.ClientStream
}

type workerTaskLogsClient struct {
	grpc.ClientStream
}

func (x *workerTaskLogsClient) Recv() (*TaskLogsChunk, error) {
	m := new(TaskLogsChunk)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *workerClient) GetDealInfo(ctx context.Context, in *ID, opts ...grpc.CallOption) (*DealInfoReply, error) {
	out := new(DealInfoReply)
	err := grpc.Invoke(ctx, "/sonm.Worker/GetDealInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Worker service

type WorkerServer interface {
	PushTask(Worker_PushTaskServer) error
	PullTask(*PullTaskRequest, Worker_PullTaskServer) error
	// StartTask schedules the task associcated with a deal.
	StartTask(context.Context, *StartTaskRequest) (*StartTaskReply, error)
	StopTask(context.Context, *ID) (*Empty, error)
	TaskStatus(context.Context, *ID) (*TaskStatusReply, error)
	JoinNetwork(context.Context, *WorkerJoinNetworkRequest) (*NetworkSpec, error)
	TaskLogs(*TaskLogsRequest, Worker_TaskLogsServer) error
	// Note: currently used for testing pusposes.
	GetDealInfo(context.Context, *ID) (*DealInfoReply, error)
}

func RegisterWorkerServer(s *grpc.Server, srv WorkerServer) {
	s.RegisterService(&_Worker_serviceDesc, srv)
}

func _Worker_PushTask_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(WorkerServer).PushTask(&workerPushTaskServer{stream})
}

type Worker_PushTaskServer interface {
	Send(*Progress) error
	Recv() (*Chunk, error)
	grpc.ServerStream
}

type workerPushTaskServer struct {
	grpc.ServerStream
}

func (x *workerPushTaskServer) Send(m *Progress) error {
	return x.ServerStream.SendMsg(m)
}

func (x *workerPushTaskServer) Recv() (*Chunk, error) {
	m := new(Chunk)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Worker_PullTask_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PullTaskRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(WorkerServer).PullTask(m, &workerPullTaskServer{stream})
}

type Worker_PullTaskServer interface {
	Send(*Chunk) error
	grpc.ServerStream
}

type workerPullTaskServer struct {
	grpc.ServerStream
}

func (x *workerPullTaskServer) Send(m *Chunk) error {
	return x.ServerStream.SendMsg(m)
}

func _Worker_StartTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).StartTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.Worker/StartTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).StartTask(ctx, req.(*StartTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_StopTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).StopTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.Worker/StopTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).StopTask(ctx, req.(*ID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_TaskStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).TaskStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.Worker/TaskStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).TaskStatus(ctx, req.(*ID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_JoinNetwork_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkerJoinNetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).JoinNetwork(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.Worker/JoinNetwork",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).JoinNetwork(ctx, req.(*WorkerJoinNetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_TaskLogs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TaskLogsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(WorkerServer).TaskLogs(m, &workerTaskLogsServer{stream})
}

type Worker_TaskLogsServer interface {
	Send(*TaskLogsChunk) error
	grpc.ServerStream
}

type workerTaskLogsServer struct {
	grpc.ServerStream
}

func (x *workerTaskLogsServer) Send(m *TaskLogsChunk) error {
	return x.ServerStream.SendMsg(m)
}

func _Worker_GetDealInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).GetDealInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.Worker/GetDealInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).GetDealInfo(ctx, req.(*ID))
	}
	return interceptor(ctx, in, info, handler)
}

var _Worker_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sonm.Worker",
	HandlerType: (*WorkerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StartTask",
			Handler:    _Worker_StartTask_Handler,
		},
		{
			MethodName: "StopTask",
			Handler:    _Worker_StopTask_Handler,
		},
		{
			MethodName: "TaskStatus",
			Handler:    _Worker_TaskStatus_Handler,
		},
		{
			MethodName: "JoinNetwork",
			Handler:    _Worker_JoinNetwork_Handler,
		},
		{
			MethodName: "GetDealInfo",
			Handler:    _Worker_GetDealInfo_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "PushTask",
			Handler:       _Worker_PushTask_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "PullTask",
			Handler:       _Worker_PullTask_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "TaskLogs",
			Handler:       _Worker_TaskLogs_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "worker.proto",
}

// Begin grpccmd
var _ = grpccmd.RunE

// WorkerManagement
var _WorkerManagementCmd = &cobra.Command{
	Use:   "workerManagement [method]",
	Short: "Subcommand for the WorkerManagement service.",
}

var _WorkerManagement_StatusCmd = &cobra.Command{
	Use:   "status",
	Short: "Make the Status method call, input-type: sonm.Empty output-type: sonm.StatusReply",
	RunE: grpccmd.RunE(
		"Status",
		"sonm.Empty",
		func(c io.Closer) interface{} {
			cc := c.(*grpc.ClientConn)
			return NewWorkerManagementClient(cc)
		},
	),
}

var _WorkerManagement_StatusCmd_gen = &cobra.Command{
	Use:   "status-gen",
	Short: "Generate JSON for method call of Status (input-type: sonm.Empty)",
	RunE:  grpccmd.TypeToJson("sonm.Empty"),
}

var _WorkerManagement_DevicesCmd = &cobra.Command{
	Use:   "devices",
	Short: "Make the Devices method call, input-type: sonm.Empty output-type: sonm.DevicesReply",
	RunE: grpccmd.RunE(
		"Devices",
		"sonm.Empty",
		func(c io.Closer) interface{} {
			cc := c.(*grpc.ClientConn)
			return NewWorkerManagementClient(cc)
		},
	),
}

var _WorkerManagement_DevicesCmd_gen = &cobra.Command{
	Use:   "devices-gen",
	Short: "Generate JSON for method call of Devices (input-type: sonm.Empty)",
	RunE:  grpccmd.TypeToJson("sonm.Empty"),
}

var _WorkerManagement_FreeDevicesCmd = &cobra.Command{
	Use:   "freeDevices",
	Short: "Make the FreeDevices method call, input-type: sonm.Empty output-type: sonm.DevicesReply",
	RunE: grpccmd.RunE(
		"FreeDevices",
		"sonm.Empty",
		func(c io.Closer) interface{} {
			cc := c.(*grpc.ClientConn)
			return NewWorkerManagementClient(cc)
		},
	),
}

var _WorkerManagement_FreeDevicesCmd_gen = &cobra.Command{
	Use:   "freeDevices-gen",
	Short: "Generate JSON for method call of FreeDevices (input-type: sonm.Empty)",
	RunE:  grpccmd.TypeToJson("sonm.Empty"),
}

var _WorkerManagement_TasksCmd = &cobra.Command{
	Use:   "tasks",
	Short: "Make the Tasks method call, input-type: sonm.Empty output-type: sonm.TaskListReply",
	RunE: grpccmd.RunE(
		"Tasks",
		"sonm.Empty",
		func(c io.Closer) interface{} {
			cc := c.(*grpc.ClientConn)
			return NewWorkerManagementClient(cc)
		},
	),
}

var _WorkerManagement_TasksCmd_gen = &cobra.Command{
	Use:   "tasks-gen",
	Short: "Generate JSON for method call of Tasks (input-type: sonm.Empty)",
	RunE:  grpccmd.TypeToJson("sonm.Empty"),
}

var _WorkerManagement_AskPlansCmd = &cobra.Command{
	Use:   "askPlans",
	Short: "Make the AskPlans method call, input-type: sonm.Empty output-type: sonm.AskPlansReply",
	RunE: grpccmd.RunE(
		"AskPlans",
		"sonm.Empty",
		func(c io.Closer) interface{} {
			cc := c.(*grpc.ClientConn)
			return NewWorkerManagementClient(cc)
		},
	),
}

var _WorkerManagement_AskPlansCmd_gen = &cobra.Command{
	Use:   "askPlans-gen",
	Short: "Generate JSON for method call of AskPlans (input-type: sonm.Empty)",
	RunE:  grpccmd.TypeToJson("sonm.Empty"),
}

var _WorkerManagement_CreateAskPlanCmd = &cobra.Command{
	Use:   "createAskPlan",
	Short: "Make the CreateAskPlan method call, input-type: sonm.AskPlan output-type: sonm.ID",
	RunE: grpccmd.RunE(
		"CreateAskPlan",
		"sonm.AskPlan",
		func(c io.Closer) interface{} {
			cc := c.(*grpc.ClientConn)
			return NewWorkerManagementClient(cc)
		},
	),
}

var _WorkerManagement_CreateAskPlanCmd_gen = &cobra.Command{
	Use:   "createAskPlan-gen",
	Short: "Generate JSON for method call of CreateAskPlan (input-type: sonm.AskPlan)",
	RunE:  grpccmd.TypeToJson("sonm.AskPlan"),
}

var _WorkerManagement_RemoveAskPlanCmd = &cobra.Command{
	Use:   "removeAskPlan",
	Short: "Make the RemoveAskPlan method call, input-type: sonm.ID output-type: sonm.Empty",
	RunE: grpccmd.RunE(
		"RemoveAskPlan",
		"sonm.ID",
		func(c io.Closer) interface{} {
			cc := c.(*grpc.ClientConn)
			return NewWorkerManagementClient(cc)
		},
	),
}

var _WorkerManagement_RemoveAskPlanCmd_gen = &cobra.Command{
	Use:   "removeAskPlan-gen",
	Short: "Generate JSON for method call of RemoveAskPlan (input-type: sonm.ID)",
	RunE:  grpccmd.TypeToJson("sonm.ID"),
}

var _WorkerManagement_PurgeAskPlansCmd = &cobra.Command{
	Use:   "purgeAskPlans",
	Short: "Make the PurgeAskPlans method call, input-type: sonm.Empty output-type: sonm.Empty",
	RunE: grpccmd.RunE(
		"PurgeAskPlans",
		"sonm.Empty",
		func(c io.Closer) interface{} {
			cc := c.(*grpc.ClientConn)
			return NewWorkerManagementClient(cc)
		},
	),
}

var _WorkerManagement_PurgeAskPlansCmd_gen = &cobra.Command{
	Use:   "purgeAskPlans-gen",
	Short: "Generate JSON for method call of PurgeAskPlans (input-type: sonm.Empty)",
	RunE:  grpccmd.TypeToJson("sonm.Empty"),
}

var _WorkerManagement_ScheduleMaintenanceCmd = &cobra.Command{
	Use:   "scheduleMaintenance",
	Short: "Make the ScheduleMaintenance method call, input-type: sonm.Timestamp output-type: sonm.Empty",
	RunE: grpccmd.RunE(
		"ScheduleMaintenance",
		"sonm.Timestamp",
		func(c io.Closer) interface{} {
			cc := c.(*grpc.ClientConn)
			return NewWorkerManagementClient(cc)
		},
	),
}

var _WorkerManagement_ScheduleMaintenanceCmd_gen = &cobra.Command{
	Use:   "scheduleMaintenance-gen",
	Short: "Generate JSON for method call of ScheduleMaintenance (input-type: sonm.Timestamp)",
	RunE:  grpccmd.TypeToJson("sonm.Timestamp"),
}

var _WorkerManagement_NextMaintenanceCmd = &cobra.Command{
	Use:   "nextMaintenance",
	Short: "Make the NextMaintenance method call, input-type: sonm.Empty output-type: sonm.Timestamp",
	RunE: grpccmd.RunE(
		"NextMaintenance",
		"sonm.Empty",
		func(c io.Closer) interface{} {
			cc := c.(*grpc.ClientConn)
			return NewWorkerManagementClient(cc)
		},
	),
}

var _WorkerManagement_NextMaintenanceCmd_gen = &cobra.Command{
	Use:   "nextMaintenance-gen",
	Short: "Generate JSON for method call of NextMaintenance (input-type: sonm.Empty)",
	RunE:  grpccmd.TypeToJson("sonm.Empty"),
}

var _WorkerManagement_DebugStateCmd = &cobra.Command{
	Use:   "debugState",
	Short: "Make the DebugState method call, input-type: sonm.Empty output-type: sonm.DebugStateReply",
	RunE: grpccmd.RunE(
		"DebugState",
		"sonm.Empty",
		func(c io.Closer) interface{} {
			cc := c.(*grpc.ClientConn)
			return NewWorkerManagementClient(cc)
		},
	),
}

var _WorkerManagement_DebugStateCmd_gen = &cobra.Command{
	Use:   "debugState-gen",
	Short: "Generate JSON for method call of DebugState (input-type: sonm.Empty)",
	RunE:  grpccmd.TypeToJson("sonm.Empty"),
}

var _WorkerManagement_RemoveBenchmarkCmd = &cobra.Command{
	Use:   "removeBenchmark",
	Short: "Make the RemoveBenchmark method call, input-type: sonm.NumericID output-type: sonm.Empty",
	RunE: grpccmd.RunE(
		"RemoveBenchmark",
		"sonm.NumericID",
		func(c io.Closer) interface{} {
			cc := c.(*grpc.ClientConn)
			return NewWorkerManagementClient(cc)
		},
	),
}

var _WorkerManagement_RemoveBenchmarkCmd_gen = &cobra.Command{
	Use:   "removeBenchmark-gen",
	Short: "Generate JSON for method call of RemoveBenchmark (input-type: sonm.NumericID)",
	RunE:  grpccmd.TypeToJson("sonm.NumericID"),
}

var _WorkerManagement_PurgeBenchmarksCmd = &cobra.Command{
	Use:   "purgeBenchmarks",
	Short: "Make the PurgeBenchmarks method call, input-type: sonm.Empty output-type: sonm.Empty",
	RunE: grpccmd.RunE(
		"PurgeBenchmarks",
		"sonm.Empty",
		func(c io.Closer) interface{} {
			cc := c.(*grpc.ClientConn)
			return NewWorkerManagementClient(cc)
		},
	),
}

var _WorkerManagement_PurgeBenchmarksCmd_gen = &cobra.Command{
	Use:   "purgeBenchmarks-gen",
	Short: "Generate JSON for method call of PurgeBenchmarks (input-type: sonm.Empty)",
	RunE:  grpccmd.TypeToJson("sonm.Empty"),
}

// Register commands with the root command and service command
func init() {
	grpccmd.RegisterServiceCmd(_WorkerManagementCmd)
	_WorkerManagementCmd.AddCommand(
		_WorkerManagement_StatusCmd,
		_WorkerManagement_StatusCmd_gen,
		_WorkerManagement_DevicesCmd,
		_WorkerManagement_DevicesCmd_gen,
		_WorkerManagement_FreeDevicesCmd,
		_WorkerManagement_FreeDevicesCmd_gen,
		_WorkerManagement_TasksCmd,
		_WorkerManagement_TasksCmd_gen,
		_WorkerManagement_AskPlansCmd,
		_WorkerManagement_AskPlansCmd_gen,
		_WorkerManagement_CreateAskPlanCmd,
		_WorkerManagement_CreateAskPlanCmd_gen,
		_WorkerManagement_RemoveAskPlanCmd,
		_WorkerManagement_RemoveAskPlanCmd_gen,
		_WorkerManagement_PurgeAskPlansCmd,
		_WorkerManagement_PurgeAskPlansCmd_gen,
		_WorkerManagement_ScheduleMaintenanceCmd,
		_WorkerManagement_ScheduleMaintenanceCmd_gen,
		_WorkerManagement_NextMaintenanceCmd,
		_WorkerManagement_NextMaintenanceCmd_gen,
		_WorkerManagement_DebugStateCmd,
		_WorkerManagement_DebugStateCmd_gen,
		_WorkerManagement_RemoveBenchmarkCmd,
		_WorkerManagement_RemoveBenchmarkCmd_gen,
		_WorkerManagement_PurgeBenchmarksCmd,
		_WorkerManagement_PurgeBenchmarksCmd_gen,
	)
}

// Worker
var _WorkerCmd = &cobra.Command{
	Use:   "worker [method]",
	Short: "Subcommand for the Worker service.",
}

var _Worker_PushTaskCmd = &cobra.Command{
	Use:   "pushTask",
	Short: "Make the PushTask method call, input-type: sonm.Chunk output-type: sonm.Progress",
	RunE: grpccmd.RunE(
		"PushTask",
		"sonm.Chunk",
		func(c io.Closer) interface{} {
			cc := c.(*grpc.ClientConn)
			return NewWorkerClient(cc)
		},
	),
}

var _Worker_PushTaskCmd_gen = &cobra.Command{
	Use:   "pushTask-gen",
	Short: "Generate JSON for method call of PushTask (input-type: sonm.Chunk)",
	RunE:  grpccmd.TypeToJson("sonm.Chunk"),
}

var _Worker_PullTaskCmd = &cobra.Command{
	Use:   "pullTask",
	Short: "Make the PullTask method call, input-type: sonm.PullTaskRequest output-type: sonm.Chunk",
	RunE: grpccmd.RunE(
		"PullTask",
		"sonm.PullTaskRequest",
		func(c io.Closer) interface{} {
			cc := c.(*grpc.ClientConn)
			return NewWorkerClient(cc)
		},
	),
}

var _Worker_PullTaskCmd_gen = &cobra.Command{
	Use:   "pullTask-gen",
	Short: "Generate JSON for method call of PullTask (input-type: sonm.PullTaskRequest)",
	RunE:  grpccmd.TypeToJson("sonm.PullTaskRequest"),
}

var _Worker_StartTaskCmd = &cobra.Command{
	Use:   "startTask",
	Short: "Make the StartTask method call, input-type: sonm.StartTaskRequest output-type: sonm.StartTaskReply",
	RunE: grpccmd.RunE(
		"StartTask",
		"sonm.StartTaskRequest",
		func(c io.Closer) interface{} {
			cc := c.(*grpc.ClientConn)
			return NewWorkerClient(cc)
		},
	),
}

var _Worker_StartTaskCmd_gen = &cobra.Command{
	Use:   "startTask-gen",
	Short: "Generate JSON for method call of StartTask (input-type: sonm.StartTaskRequest)",
	RunE:  grpccmd.TypeToJson("sonm.StartTaskRequest"),
}

var _Worker_StopTaskCmd = &cobra.Command{
	Use:   "stopTask",
	Short: "Make the StopTask method call, input-type: sonm.ID output-type: sonm.Empty",
	RunE: grpccmd.RunE(
		"StopTask",
		"sonm.ID",
		func(c io.Closer) interface{} {
			cc := c.(*grpc.ClientConn)
			return NewWorkerClient(cc)
		},
	),
}

var _Worker_StopTaskCmd_gen = &cobra.Command{
	Use:   "stopTask-gen",
	Short: "Generate JSON for method call of StopTask (input-type: sonm.ID)",
	RunE:  grpccmd.TypeToJson("sonm.ID"),
}

var _Worker_TaskStatusCmd = &cobra.Command{
	Use:   "taskStatus",
	Short: "Make the TaskStatus method call, input-type: sonm.ID output-type: sonm.TaskStatusReply",
	RunE: grpccmd.RunE(
		"TaskStatus",
		"sonm.ID",
		func(c io.Closer) interface{} {
			cc := c.(*grpc.ClientConn)
			return NewWorkerClient(cc)
		},
	),
}

var _Worker_TaskStatusCmd_gen = &cobra.Command{
	Use:   "taskStatus-gen",
	Short: "Generate JSON for method call of TaskStatus (input-type: sonm.ID)",
	RunE:  grpccmd.TypeToJson("sonm.ID"),
}

var _Worker_JoinNetworkCmd = &cobra.Command{
	Use:   "joinNetwork",
	Short: "Make the JoinNetwork method call, input-type: sonm.WorkerJoinNetworkRequest output-type: sonm.NetworkSpec",
	RunE: grpccmd.RunE(
		"JoinNetwork",
		"sonm.WorkerJoinNetworkRequest",
		func(c io.Closer) interface{} {
			cc := c.(*grpc.ClientConn)
			return NewWorkerClient(cc)
		},
	),
}

var _Worker_JoinNetworkCmd_gen = &cobra.Command{
	Use:   "joinNetwork-gen",
	Short: "Generate JSON for method call of JoinNetwork (input-type: sonm.WorkerJoinNetworkRequest)",
	RunE:  grpccmd.TypeToJson("sonm.WorkerJoinNetworkRequest"),
}

var _Worker_TaskLogsCmd = &cobra.Command{
	Use:   "taskLogs",
	Short: "Make the TaskLogs method call, input-type: sonm.TaskLogsRequest output-type: sonm.TaskLogsChunk",
	RunE: grpccmd.RunE(
		"TaskLogs",
		"sonm.TaskLogsRequest",
		func(c io.Closer) interface{} {
			cc := c.(*grpc.ClientConn)
			return NewWorkerClient(cc)
		},
	),
}

var _Worker_TaskLogsCmd_gen = &cobra.Command{
	Use:   "taskLogs-gen",
	Short: "Generate JSON for method call of TaskLogs (input-type: sonm.TaskLogsRequest)",
	RunE:  grpccmd.TypeToJson("sonm.TaskLogsRequest"),
}

var _Worker_GetDealInfoCmd = &cobra.Command{
	Use:   "getDealInfo",
	Short: "Make the GetDealInfo method call, input-type: sonm.ID output-type: sonm.DealInfoReply",
	RunE: grpccmd.RunE(
		"GetDealInfo",
		"sonm.ID",
		func(c io.Closer) interface{} {
			cc := c.(*grpc.ClientConn)
			return NewWorkerClient(cc)
		},
	),
}

var _Worker_GetDealInfoCmd_gen = &cobra.Command{
	Use:   "getDealInfo-gen",
	Short: "Generate JSON for method call of GetDealInfo (input-type: sonm.ID)",
	RunE:  grpccmd.TypeToJson("sonm.ID"),
}

// Register commands with the root command and service command
func init() {
	grpccmd.RegisterServiceCmd(_WorkerCmd)
	_WorkerCmd.AddCommand(
		_Worker_PushTaskCmd,
		_Worker_PushTaskCmd_gen,
		_Worker_PullTaskCmd,
		_Worker_PullTaskCmd_gen,
		_Worker_StartTaskCmd,
		_Worker_StartTaskCmd_gen,
		_Worker_StopTaskCmd,
		_Worker_StopTaskCmd_gen,
		_Worker_TaskStatusCmd,
		_Worker_TaskStatusCmd_gen,
		_Worker_JoinNetworkCmd,
		_Worker_JoinNetworkCmd_gen,
		_Worker_TaskLogsCmd,
		_Worker_TaskLogsCmd_gen,
		_Worker_GetDealInfoCmd,
		_Worker_GetDealInfoCmd_gen,
	)
}

// End grpccmd

func init() { proto.RegisterFile("worker.proto", fileDescriptor14) }

var fileDescriptor14 = []byte{
	// 1683 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0x4f, 0x6f, 0x23, 0x49,
	0x15, 0x77, 0xc7, 0x8e, 0xff, 0x3c, 0xdb, 0xb1, 0xa7, 0xb2, 0x1b, 0x59, 0xcd, 0xcc, 0x90, 0xed,
	0x65, 0xc1, 0x64, 0x77, 0x4c, 0xd6, 0xbb, 0xac, 0x60, 0x16, 0xa4, 0x75, 0xe2, 0x24, 0xeb, 0x9d,
	0xc4, 0x31, 0xe5, 0x58, 0xe1, 0x80, 0x84, 0x2a, 0x76, 0xc5, 0x69, 0xb9, 0x5d, 0xdd, 0x74, 0x57,
	0x07, 0xc2, 0x99, 0x1b, 0x37, 0x8e, 0x88, 0xcf, 0xc0, 0x1d, 0xc1, 0x27, 0xe0, 0x3b, 0xf0, 0x19,
	0xb8, 0x71, 0x44, 0xa8, 0xba, 0xaa, 0xfa, 0x8f, 0xd3, 0x41, 0x3b, 0xd2, 0xdc, 0x5c, 0xef, 0xfd,
	0x7e, 0xaf, 0x5e, 0xbd, 0x7f, 0x5d, 0x65, 0x68, 0xfc, 0xd6, 0xf5, 0x57, 0xd4, 0xef, 0x79, 0xbe,
	0xcb, 0x5d, 0x54, 0x0a, 0x5c, 0xb6, 0x36, 0x77, 0x48, 0xb0, 0xfa, 0xb5, 0xe7, 0x10, 0x26, 0xa5,
	0x66, 0xe3, 0xc6, 0x5e, 0xda, 0x8c, 0xab, 0x15, 0x9a, 0x13, 0x8f, 0xdc, 0xd8, 0x8e, 0xcd, 0x6d,
	0x1a, 0x28, 0x59, 0x6b, 0xee, 0x32, 0x4e, 0x6c, 0xa6, 0x0d, 0x99, 0x2d, 0x9b, 0x09, 0x53, 0xcc,
	0x26, 0x4a, 0xf0, 0x6c, 0x4d, 0xfc, 0x15, 0xe5, 0x9e, 0x43, 0xe6, 0x54, 0x89, 0x6a, 0x8c, 0x6a,
	0x9b, 0x2d, 0x6e, 0xaf, 0x69, 0xc0, 0xc9, 0xda, 0x93, 0x02, 0xeb, 0x05, 0x54, 0xae, 0x48, 0xb0,
	0xba, 0x22, 0x4b, 0x84, 0xa0, 0xb4, 0x20, 0x9c, 0x74, 0x8c, 0x7d, 0xa3, 0xdb, 0xc0, 0xd1, 0x6f,
	0xeb, 0x1f, 0x06, 0x54, 0x85, 0x7e, 0xea, 0xd1, 0x39, 0x7a, 0x05, 0xb5, 0x78, 0xfb, 0x08, 0x55,
	0xef, 0xb7, 0x7a, 0x62, 0xf7, 0xde, 0xb1, 0x16, 0xe3, 0x04, 0x81, 0x0e, 0xa0, 0xea, 0xd3, 0xa5,
	0x1d, 0x70, 0xff, 0xa1, 0xb3, 0x15, 0xa1, 0x77, 0x24, 0x1a, 0x2b, 0x29, 0x8e, 0xf5, 0xe8, 0x73,
	0xa8, 0xf9, 0x34, 0x70, 0x43, 0x7f, 0x4e, 0x83, 0x4e, 0x31, 0x02, 0xef, 0x49, 0xf0, 0x20, 0x58,
	0x4d, 0x1c, 0xc2, 0xb0, 0xd6, 0xe2, 0x04, 0x88, 0xbe, 0x0b, 0x45, 0x4e, 0x96, 0x9d, 0x52, 0x84,
	0x6f, 0x4a, 0xbc, 0x3a, 0x0d, 0x16, 0x1a, 0xeb, 0x57, 0xd0, 0x9e, 0x72, 0xe2, 0x73, 0x21, 0xc4,
	0xf4, 0x37, 0x21, 0x0d, 0x38, 0xfa, 0x1e, 0x94, 0x17, 0x94, 0x38, 0xa3, 0xa1, 0x3a, 0x42, 0x43,
	0xf2, 0x8e, 0xec, 0xe5, 0x88, 0x71, 0xac, 0x74, 0xc8, 0x82, 0x52, 0xe0, 0xd1, 0x79, 0xd6, 0x71,
	0x1d, 0x09, 0x1c, 0xe9, 0xac, 0x09, 0x74, 0xae, 0xa3, 0xa4, 0x7e, 0xe3, 0xda, 0x6c, 0x4c, 0xb9,
	0xc8, 0xb0, 0xde, 0x65, 0x0f, 0xca, 0x9c, 0x04, 0x2b, 0xb5, 0x4b, 0x0d, 0xab, 0x15, 0x7a, 0x0e,
	0x22, 0x1b, 0x02, 0x39, 0x1a, 0x46, 0xc6, 0x6b, 0x38, 0x11, 0x58, 0xff, 0x34, 0x60, 0x27, 0xe5,
	0xb0, 0xe7, 0x3c, 0xa0, 0x1d, 0xd8, 0xb2, 0x17, 0xca, 0xc8, 0x96, 0xbd, 0x40, 0x5f, 0x42, 0xc5,
	0x73, 0x7d, 0x7e, 0x41, 0xbc, 0xce, 0xd6, 0x7e, 0xb1, 0x5b, 0xef, 0x7f, 0x20, 0x7d, 0xcb, 0xd2,
	0x7a, 0x13, 0x89, 0x39, 0x61, 0x22, 0xce, 0x9a, 0x81, 0x5e, 0x02, 0xc4, 0x9b, 0x89, 0x38, 0x17,
	0xbb, 0x35, 0x9c, 0x92, 0x98, 0x6f, 0xa0, 0x91, 0x26, 0xa2, 0x36, 0x14, 0x57, 0xf4, 0x41, 0xed,
	0x2e, 0x7e, 0xa2, 0x8f, 0x60, 0xfb, 0x9e, 0x38, 0x21, 0x55, 0x81, 0x51, 0xf9, 0x3f, 0x61, 0x0b,
	0xcf, 0xb5, 0x19, 0x0f, 0xb0, 0xd4, 0xbe, 0xde, 0xfa, 0x89, 0x61, 0xfd, 0xcb, 0x80, 0xfa, 0x94,
	0x13, 0x1e, 0x06, 0xf2, 0x24, 0x7b, 0x50, 0x0e, 0x3d, 0x51, 0x7f, 0x91, 0xbd, 0x12, 0x56, 0x2b,
	0xd4, 0x81, 0xca, 0x3d, 0xf5, 0x03, 0xdb, 0x65, 0x2a, 0x20, 0x7a, 0x89, 0x4c, 0xa8, 0x7a, 0x0e,
	0xe1, 0xb7, 0xae, 0xbf, 0x8e, 0x8a, 0xa2, 0x86, 0xe3, 0xb5, 0x60, 0x51, 0x7e, 0x37, 0x58, 0x2c,
	0xfc, 0x28, 0xff, 0x35, 0xac, 0x97, 0x22, 0xc4, 0x22, 0xd8, 0xc7, 0x6e, 0xc8, 0x78, 0x67, 0x7b,
	0xdf, 0xe8, 0x36, 0x71, 0x22, 0x10, 0xda, 0xe1, 0xf5, 0xd7, 0xd2, 0xaf, 0x4e, 0x59, 0x26, 0x20,
	0x16, 0xa0, 0x03, 0x68, 0xfb, 0x94, 0x2d, 0xe8, 0xef, 0xef, 0xdd, 0x30, 0x50, 0xa0, 0x4a, 0x04,
	0x7a, 0x24, 0xb7, 0xfe, 0x6c, 0x40, 0x53, 0x55, 0xa7, 0x3a, 0xe1, 0xcf, 0xa1, 0x4a, 0x94, 0xa0,
	0x63, 0xa4, 0x93, 0x93, 0x81, 0xc5, 0x2b, 0x99, 0x9c, 0x98, 0x62, 0x7e, 0x93, 0xd8, 0x7b, 0x2a,
	0xfc, 0x1f, 0x66, 0xc3, 0xdf, 0xcc, 0xf6, 0x48, 0x2a, 0xf8, 0x7f, 0x32, 0xa0, 0x29, 0xaa, 0xe1,
	0xdc, 0x0e, 0xb8, 0x74, 0xee, 0x53, 0x28, 0xd9, 0xec, 0xd6, 0x55, 0x8e, 0xbd, 0x48, 0x2a, 0x3a,
	0x86, 0xf4, 0x46, 0xec, 0xd6, 0x95, 0x4e, 0x45, 0x50, 0x73, 0x0c, 0xb5, 0x58, 0x94, 0xe3, 0xcc,
	0xc7, 0x59, 0x67, 0xde, 0x4f, 0x35, 0x49, 0x92, 0xf6, 0xb4, 0x53, 0x7f, 0x33, 0xa0, 0x31, 0xa4,
	0xf7, 0xb6, 0x68, 0xe3, 0xc8, 0xa7, 0xef, 0x40, 0xf1, 0x78, 0x32, 0x53, 0x8d, 0x58, 0x53, 0xb3,
	0x64, 0x32, 0xc3, 0x42, 0x8a, 0x5e, 0x40, 0xe9, 0x6c, 0x32, 0x0b, 0x54, 0x99, 0x2b, 0xed, 0xd9,
	0x64, 0x86, 0x23, 0xb1, 0xe0, 0xe2, 0xc1, 0x85, 0x1a, 0x16, 0x4a, 0x8b, 0x07, 0x17, 0x58, 0x48,
	0xd1, 0x0f, 0xa0, 0xa2, 0xca, 0x3a, 0x3b, 0x1d, 0x74, 0x97, 0x6a, 0xad, 0x00, 0x06, 0xdc, 0xf5,
	0xc9, 0x92, 0x46, 0xa5, 0x12, 0x03, 0xa7, 0x52, 0x88, 0xb5, 0xd6, 0x1a, 0x40, 0x6b, 0x12, 0x3a,
	0x4e, 0x7a, 0x92, 0xec, 0xa9, 0x49, 0xa2, 0xdb, 0x53, 0xad, 0xe2, 0xde, 0x5f, 0xa8, 0x7a, 0x56,
	0x2b, 0xeb, 0x8f, 0x45, 0x68, 0x0e, 0x05, 0x84, 0xdd, 0xba, 0xf2, 0xfc, 0x2f, 0xa1, 0x24, 0x38,
	0x2a, 0x00, 0x20, 0xb7, 0x16, 0x10, 0x1c, 0xc9, 0xd1, 0x6b, 0xa8, 0xf8, 0x21, 0x63, 0x36, 0x5b,
	0xaa, 0x28, 0xec, 0x27, 0x90, 0xd8, 0x4a, 0x0f, 0x4b, 0x88, 0xea, 0x75, 0x45, 0x40, 0x5f, 0x89,
	0x69, 0xbd, 0xf6, 0x1c, 0xca, 0xe9, 0x22, 0x6a, 0xf5, 0x7a, 0xdf, 0xca, 0x63, 0x1f, 0x6b, 0x90,
	0xe4, 0x27, 0xa4, 0xec, 0x50, 0x2e, 0x7d, 0xcb, 0xa1, 0x6c, 0xfe, 0x02, 0x1a, 0x69, 0x87, 0xde,
	0x41, 0xdd, 0x98, 0x53, 0xd8, 0xc9, 0x7a, 0xf9, 0x2e, 0x8a, 0xf1, 0x3f, 0x45, 0x68, 0x6d, 0xa8,
	0xd1, 0xe7, 0x50, 0x0e, 0x64, 0xd3, 0x0b, 0xcb, 0x3b, 0xfd, 0xe7, 0xb9, 0x56, 0x7a, 0xea, 0xb7,
	0xc2, 0x8a, 0x91, 0x62, 0xaf, 0xc9, 0x92, 0x8e, 0xc9, 0x9a, 0xea, 0x99, 0x1e, 0x0b, 0xd0, 0xcf,
	0x92, 0x81, 0x9d, 0xc9, 0xc2, 0xa6, 0xd1, 0xfc, 0x89, 0x9d, 0x0c, 0xcd, 0x52, 0x66, 0x68, 0xfe,
	0x10, 0xb6, 0xc3, 0x20, 0xa9, 0xda, 0x5d, 0xfd, 0x65, 0x95, 0x59, 0x98, 0x09, 0x15, 0x96, 0x08,
	0x74, 0x0a, 0x88, 0x38, 0x8e, 0x3b, 0x27, 0x9c, 0x2e, 0xe2, 0x8c, 0x45, 0xa3, 0xef, 0xe9, 0x7c,
	0xe6, 0x30, 0xf4, 0xd7, 0xb6, 0xf2, 0xd4, 0xd7, 0xf6, 0xdd, 0x7e, 0x3d, 0x7e, 0x09, 0x65, 0x35,
	0x93, 0xeb, 0x50, 0x99, 0x8d, 0xdf, 0x8c, 0x2f, 0xaf, 0xc7, 0xed, 0x02, 0x6a, 0x40, 0x75, 0x3a,
	0xb9, 0xbc, 0x3c, 0x1f, 0x8d, 0xcf, 0xda, 0x86, 0x5c, 0x0d, 0xae, 0xc7, 0x62, 0xb5, 0x25, 0x80,
	0x78, 0x36, 0x8e, 0x16, 0x45, 0xa1, 0x3a, 0x1d, 0x8d, 0x47, 0xd3, 0xaf, 0x4f, 0x86, 0xed, 0x12,
	0x02, 0x28, 0x1f, 0xe1, 0xcb, 0x37, 0x27, 0xe3, 0xf6, 0xb6, 0xf5, 0x77, 0x03, 0x1a, 0xfa, 0x54,
	0x13, 0xd7, 0x75, 0x50, 0x17, 0x8a, 0xc4, 0xd1, 0x4d, 0xf8, 0x54, 0x44, 0x04, 0x04, 0x1d, 0x42,
	0x29, 0x0c, 0xe8, 0x42, 0x35, 0xe3, 0xf3, 0x6c, 0xd0, 0x85, 0xad, 0xde, 0x2c, 0xd0, 0x8d, 0x14,
	0x21, 0xcd, 0x4b, 0xa8, 0xc5, 0xa2, 0x9c, 0x80, 0x7c, 0x92, 0x0d, 0xc8, 0x53, 0x9b, 0xa7, 0xe2,
	0xf2, 0xef, 0x2d, 0x68, 0x4e, 0xe7, 0x77, 0x74, 0x11, 0x3a, 0xd4, 0x1f, 0x12, 0x4e, 0xd0, 0x39,
	0x34, 0xc5, 0x80, 0xb9, 0x72, 0x15, 0x4d, 0x4d, 0xf8, 0xef, 0xab, 0x41, 0x96, 0xc6, 0xca, 0x7c,
	0x69, 0xa0, 0xf4, 0x33, 0x4b, 0x46, 0x3d, 0xa8, 0xae, 0x89, 0xcd, 0xc4, 0x61, 0x94, 0x53, 0xe8,
	0xf1, 0x31, 0x71, 0x8c, 0x41, 0x23, 0x68, 0xa8, 0x0f, 0x98, 0x58, 0x06, 0xaa, 0xc6, 0x3f, 0xca,
	0xdb, 0x7c, 0x90, 0xc2, 0xc9, 0xbd, 0x33, 0x54, 0xf3, 0x2b, 0x40, 0x8f, 0xfd, 0xcb, 0x09, 0xda,
	0x7b, 0xe9, 0xa0, 0xd5, 0xb2, 0x83, 0xe2, 0xd9, 0xa3, 0x4d, 0x72, 0x0c, 0x74, 0xb3, 0x51, 0xcf,
	0x3b, 0x60, 0x2a, 0xe2, 0x7f, 0x29, 0x42, 0x63, 0x4a, 0x1c, 0x1a, 0xac, 0x09, 0x8b, 0x02, 0x3e,
	0x86, 0x1d, 0xe5, 0xf7, 0xf1, 0x99, 0xef, 0x86, 0x9e, 0xfe, 0x44, 0xe9, 0x88, 0xa7, 0xb0, 0xfa,
	0xcc, 0x0a, 0x28, 0x4f, 0xbd, 0xc1, 0x46, 0x9f, 0xc1, 0xb6, 0x98, 0xf6, 0x3a, 0x76, 0x2f, 0x72,
	0xcc, 0x88, 0x91, 0xad, 0xd8, 0x12, 0x8b, 0xbe, 0x80, 0xb2, 0xeb, 0x2f, 0xa8, 0x2f, 0x26, 0xb3,
	0x60, 0xbd, 0xcc, 0x61, 0x5d, 0x46, 0x00, 0x49, 0x53, 0x68, 0x73, 0x00, 0xbb, 0x39, 0x3e, 0xbd,
	0x55, 0x94, 0x87, 0x00, 0x89, 0x3f, 0x39, 0xcc, 0xfd, 0x6c, 0x78, 0xd3, 0x9f, 0xb5, 0x94, 0x95,
	0x53, 0xa8, 0xa7, 0xfc, 0xcb, 0x31, 0xf3, 0x41, 0xd6, 0x4c, 0x5d, 0x9a, 0x89, 0x38, 0xe9, 0xf4,
	0xfc, 0xc1, 0x80, 0xd6, 0x90, 0xde, 0x84, 0x4b, 0x31, 0x2e, 0xa8, 0x9c, 0xe3, 0x3f, 0x85, 0x66,
	0x90, 0x2e, 0x3d, 0xd5, 0xdb, 0xbb, 0x39, 0x55, 0x89, 0xb3, 0x48, 0xf4, 0x05, 0x34, 0x82, 0x54,
	0x0c, 0xb3, 0x25, 0x92, 0x8e, 0x2e, 0xce, 0xe0, 0xfa, 0xff, 0x2d, 0x41, 0x5b, 0xbe, 0x06, 0x2e,
	0x08, 0x23, 0x4b, 0xba, 0xa6, 0x8c, 0xa3, 0x83, 0x64, 0x88, 0xa9, 0x51, 0xb7, 0xf6, 0xf8, 0x83,
	0xf9, 0x2c, 0xbe, 0xb2, 0xeb, 0xe9, 0x6f, 0x15, 0xd0, 0x27, 0x50, 0x51, 0x77, 0xa3, 0x2c, 0x18,
	0xe9, 0xf0, 0x25, 0xf7, 0x26, 0xab, 0x80, 0x0e, 0xa1, 0x7e, 0xea, 0x53, 0xfa, 0x16, 0x8c, 0x8f,
	0x61, 0x5b, 0x74, 0xd7, 0x06, 0x76, 0x37, 0xe7, 0x1e, 0x68, 0x15, 0xc4, 0x14, 0xd0, 0x57, 0xd1,
	0x5c, 0x7c, 0xe6, 0x42, 0x6b, 0x15, 0xd0, 0x01, 0x34, 0x8f, 0x7d, 0x4a, 0x38, 0xd5, 0x63, 0x24,
	0x7b, 0x33, 0x35, 0xab, 0x72, 0x39, 0x1a, 0x5a, 0x05, 0xd4, 0x85, 0x26, 0xa6, 0x6b, 0xf7, 0x3e,
	0xc6, 0xc6, 0x4a, 0x33, 0xbd, 0x55, 0xe4, 0x72, 0x73, 0x12, 0xfa, 0x4b, 0x9a, 0xef, 0xca, 0x06,
	0xf8, 0xc7, 0xb0, 0xab, 0x13, 0x7b, 0x41, 0x6c, 0xc6, 0x29, 0x23, 0x6c, 0x4e, 0x91, 0xfa, 0xc6,
	0x5c, 0xe9, 0x77, 0xef, 0x26, 0xed, 0x53, 0x68, 0x8d, 0xe9, 0xef, 0x78, 0x9a, 0x92, 0xd9, 0x65,
	0x93, 0x6f, 0x15, 0x50, 0x5f, 0xd4, 0xbf, 0x2e, 0xb8, 0x2c, 0xfa, 0x7d, 0x1d, 0xfa, 0x4c, 0x3d,
	0xca, 0x6d, 0xe4, 0xa1, 0x8f, 0x28, 0x9b, 0xdf, 0x89, 0x37, 0xba, 0xf6, 0x6c, 0x1c, 0xae, 0xa9,
	0x6f, 0xcf, 0x1f, 0x9f, 0xfe, 0x95, 0xb8, 0x71, 0xfa, 0xcb, 0x84, 0xf1, 0x7f, 0xcf, 0xdf, 0xff,
	0x6b, 0x11, 0xca, 0xb2, 0x00, 0xd1, 0x2b, 0xa8, 0x4e, 0xc2, 0xe0, 0x4e, 0x24, 0x55, 0x53, 0x8e,
	0xef, 0x42, 0xb6, 0x32, 0xd5, 0x3b, 0x76, 0xe2, 0xbb, 0x4b, 0x9f, 0x06, 0x81, 0x55, 0xe8, 0x1a,
	0x87, 0x06, 0xea, 0x0b, 0xb8, 0xbc, 0xda, 0x22, 0x75, 0x80, 0x8d, 0xab, 0xae, 0x99, 0xb6, 0x62,
	0x15, 0x0e, 0x0d, 0xf4, 0x25, 0xd4, 0xe2, 0x17, 0x27, 0xda, 0x7b, 0xf4, 0x04, 0x95, 0xac, 0xf7,
	0xf2, 0x9e, 0xa6, 0x56, 0x01, 0x7d, 0x08, 0xd5, 0x29, 0x77, 0xbd, 0x88, 0xfb, 0x64, 0xf2, 0x7f,
	0x04, 0x90, 0x5c, 0x91, 0x52, 0xb0, 0xfc, 0x9b, 0x9d, 0x55, 0x40, 0x47, 0x50, 0x4f, 0x3d, 0xc4,
	0x91, 0x1a, 0x88, 0x4f, 0xbd, 0xd0, 0x75, 0x13, 0x2a, 0xa9, 0x78, 0xd6, 0x5b, 0x05, 0xf4, 0x5a,
	0xfe, 0xdd, 0x71, 0xee, 0x2e, 0x03, 0x94, 0xda, 0x48, 0xac, 0x35, 0x6f, 0x37, 0x2b, 0x4e, 0x42,
	0xd2, 0x83, 0xfa, 0x19, 0xe5, 0xfa, 0x72, 0x9d, 0xf2, 0x78, 0x37, 0xe7, 0xda, 0x6d, 0x15, 0x6e,
	0xca, 0xd1, 0x3f, 0x30, 0x9f, 0xfd, 0x2f, 0x00, 0x00, 0xff, 0xff, 0xcb, 0x67, 0x8f, 0xb3, 0x1a,
	0x12, 0x00, 0x00,
}
