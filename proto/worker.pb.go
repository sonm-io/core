// Code generated by protoc-gen-go. DO NOT EDIT.
// source: worker.proto

package sonm

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type TaskStatusReply_Status int32

const (
	TaskStatusReply_UNKNOWN  TaskStatusReply_Status = 0
	TaskStatusReply_SPOOLING TaskStatusReply_Status = 1
	TaskStatusReply_SPAWNING TaskStatusReply_Status = 2
	TaskStatusReply_RUNNING  TaskStatusReply_Status = 3
	TaskStatusReply_FINISHED TaskStatusReply_Status = 4
	TaskStatusReply_BROKEN   TaskStatusReply_Status = 5
)

var TaskStatusReply_Status_name = map[int32]string{
	0: "UNKNOWN",
	1: "SPOOLING",
	2: "SPAWNING",
	3: "RUNNING",
	4: "FINISHED",
	5: "BROKEN",
}
var TaskStatusReply_Status_value = map[string]int32{
	"UNKNOWN":  0,
	"SPOOLING": 1,
	"SPAWNING": 2,
	"RUNNING":  3,
	"FINISHED": 4,
	"BROKEN":   5,
}

func (x TaskStatusReply_Status) String() string {
	return proto.EnumName(TaskStatusReply_Status_name, int32(x))
}
func (TaskStatusReply_Status) EnumDescriptor() ([]byte, []int) { return fileDescriptor16, []int{11, 0} }

type TaskTag struct {
	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *TaskTag) Reset()                    { *m = TaskTag{} }
func (m *TaskTag) String() string            { return proto.CompactTextString(m) }
func (*TaskTag) ProtoMessage()               {}
func (*TaskTag) Descriptor() ([]byte, []int) { return fileDescriptor16, []int{0} }

func (m *TaskTag) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type TaskSpec struct {
	// Container describes container settings.
	Container *Container        `protobuf:"bytes,1,opt,name=container" json:"container,omitempty"`
	Registry  *Registry         `protobuf:"bytes,2,opt,name=registry" json:"registry,omitempty"`
	Resources *AskPlanResources `protobuf:"bytes,3,opt,name=resources" json:"resources,omitempty"`
	Tag       *TaskTag          `protobuf:"bytes,4,opt,name=tag" json:"tag,omitempty"`
}

func (m *TaskSpec) Reset()                    { *m = TaskSpec{} }
func (m *TaskSpec) String() string            { return proto.CompactTextString(m) }
func (*TaskSpec) ProtoMessage()               {}
func (*TaskSpec) Descriptor() ([]byte, []int) { return fileDescriptor16, []int{1} }

func (m *TaskSpec) GetContainer() *Container {
	if m != nil {
		return m.Container
	}
	return nil
}

func (m *TaskSpec) GetRegistry() *Registry {
	if m != nil {
		return m.Registry
	}
	return nil
}

func (m *TaskSpec) GetResources() *AskPlanResources {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *TaskSpec) GetTag() *TaskTag {
	if m != nil {
		return m.Tag
	}
	return nil
}

type StartTaskRequest struct {
	// Deal points to the deal associated with workers where the task should be
	// started.
	DealID *BigInt   `protobuf:"bytes,1,opt,name=dealID" json:"dealID,omitempty"`
	Spec   *TaskSpec `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
}

func (m *StartTaskRequest) Reset()                    { *m = StartTaskRequest{} }
func (m *StartTaskRequest) String() string            { return proto.CompactTextString(m) }
func (*StartTaskRequest) ProtoMessage()               {}
func (*StartTaskRequest) Descriptor() ([]byte, []int) { return fileDescriptor16, []int{2} }

func (m *StartTaskRequest) GetDealID() *BigInt {
	if m != nil {
		return m.DealID
	}
	return nil
}

func (m *StartTaskRequest) GetSpec() *TaskSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

type WorkerJoinNetworkRequest struct {
	TaskID    string `protobuf:"bytes,1,opt,name=taskID" json:"taskID,omitempty"`
	NetworkID string `protobuf:"bytes,2,opt,name=networkID" json:"networkID,omitempty"`
}

func (m *WorkerJoinNetworkRequest) Reset()                    { *m = WorkerJoinNetworkRequest{} }
func (m *WorkerJoinNetworkRequest) String() string            { return proto.CompactTextString(m) }
func (*WorkerJoinNetworkRequest) ProtoMessage()               {}
func (*WorkerJoinNetworkRequest) Descriptor() ([]byte, []int) { return fileDescriptor16, []int{3} }

func (m *WorkerJoinNetworkRequest) GetTaskID() string {
	if m != nil {
		return m.TaskID
	}
	return ""
}

func (m *WorkerJoinNetworkRequest) GetNetworkID() string {
	if m != nil {
		return m.NetworkID
	}
	return ""
}

type StartTaskReply struct {
	Id         string                `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	PortMap    map[string]*Endpoints `protobuf:"bytes,2,rep,name=portMap" json:"portMap,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	NetworkIDs []string              `protobuf:"bytes,3,rep,name=networkIDs" json:"networkIDs,omitempty"`
}

func (m *StartTaskReply) Reset()                    { *m = StartTaskReply{} }
func (m *StartTaskReply) String() string            { return proto.CompactTextString(m) }
func (*StartTaskReply) ProtoMessage()               {}
func (*StartTaskReply) Descriptor() ([]byte, []int) { return fileDescriptor16, []int{4} }

func (m *StartTaskReply) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *StartTaskReply) GetPortMap() map[string]*Endpoints {
	if m != nil {
		return m.PortMap
	}
	return nil
}

func (m *StartTaskReply) GetNetworkIDs() []string {
	if m != nil {
		return m.NetworkIDs
	}
	return nil
}

type StatusReply struct {
	Uptime              uint64      `protobuf:"varint,1,opt,name=uptime" json:"uptime,omitempty"`
	Version             string      `protobuf:"bytes,2,opt,name=version" json:"version,omitempty"`
	Platform            string      `protobuf:"bytes,3,opt,name=platform" json:"platform,omitempty"`
	EthAddr             string      `protobuf:"bytes,4,opt,name=ethAddr" json:"ethAddr,omitempty"`
	TaskCount           uint32      `protobuf:"varint,5,opt,name=taskCount" json:"taskCount,omitempty"`
	DWHStatus           string      `protobuf:"bytes,6,opt,name=DWHStatus" json:"DWHStatus,omitempty"`
	RendezvousStatus    string      `protobuf:"bytes,7,opt,name=rendezvousStatus" json:"rendezvousStatus,omitempty"`
	Master              *EthAddress `protobuf:"bytes,8,opt,name=master" json:"master,omitempty"`
	Admin               *EthAddress `protobuf:"bytes,9,opt,name=admin" json:"admin,omitempty"`
	IsMasterConfirmed   bool        `protobuf:"varint,10,opt,name=isMasterConfirmed" json:"isMasterConfirmed,omitempty"`
	IsBenchmarkFinished bool        `protobuf:"varint,11,opt,name=isBenchmarkFinished" json:"isBenchmarkFinished,omitempty"`
	Geo                 *GeoIP      `protobuf:"bytes,12,opt,name=geo" json:"geo,omitempty"`
}

func (m *StatusReply) Reset()                    { *m = StatusReply{} }
func (m *StatusReply) String() string            { return proto.CompactTextString(m) }
func (*StatusReply) ProtoMessage()               {}
func (*StatusReply) Descriptor() ([]byte, []int) { return fileDescriptor16, []int{5} }

func (m *StatusReply) GetUptime() uint64 {
	if m != nil {
		return m.Uptime
	}
	return 0
}

func (m *StatusReply) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *StatusReply) GetPlatform() string {
	if m != nil {
		return m.Platform
	}
	return ""
}

func (m *StatusReply) GetEthAddr() string {
	if m != nil {
		return m.EthAddr
	}
	return ""
}

func (m *StatusReply) GetTaskCount() uint32 {
	if m != nil {
		return m.TaskCount
	}
	return 0
}

func (m *StatusReply) GetDWHStatus() string {
	if m != nil {
		return m.DWHStatus
	}
	return ""
}

func (m *StatusReply) GetRendezvousStatus() string {
	if m != nil {
		return m.RendezvousStatus
	}
	return ""
}

func (m *StatusReply) GetMaster() *EthAddress {
	if m != nil {
		return m.Master
	}
	return nil
}

func (m *StatusReply) GetAdmin() *EthAddress {
	if m != nil {
		return m.Admin
	}
	return nil
}

func (m *StatusReply) GetIsMasterConfirmed() bool {
	if m != nil {
		return m.IsMasterConfirmed
	}
	return false
}

func (m *StatusReply) GetIsBenchmarkFinished() bool {
	if m != nil {
		return m.IsBenchmarkFinished
	}
	return false
}

func (m *StatusReply) GetGeo() *GeoIP {
	if m != nil {
		return m.Geo
	}
	return nil
}

type AskPlansReply struct {
	AskPlans map[string]*AskPlan `protobuf:"bytes,1,rep,name=askPlans" json:"askPlans,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *AskPlansReply) Reset()                    { *m = AskPlansReply{} }
func (m *AskPlansReply) String() string            { return proto.CompactTextString(m) }
func (*AskPlansReply) ProtoMessage()               {}
func (*AskPlansReply) Descriptor() ([]byte, []int) { return fileDescriptor16, []int{6} }

func (m *AskPlansReply) GetAskPlans() map[string]*AskPlan {
	if m != nil {
		return m.AskPlans
	}
	return nil
}

type TaskListReply struct {
	Info map[string]*TaskStatusReply `protobuf:"bytes,1,rep,name=info" json:"info,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *TaskListReply) Reset()                    { *m = TaskListReply{} }
func (m *TaskListReply) String() string            { return proto.CompactTextString(m) }
func (*TaskListReply) ProtoMessage()               {}
func (*TaskListReply) Descriptor() ([]byte, []int) { return fileDescriptor16, []int{7} }

func (m *TaskListReply) GetInfo() map[string]*TaskStatusReply {
	if m != nil {
		return m.Info
	}
	return nil
}

type DevicesReply struct {
	CPU     *CPU     `protobuf:"bytes,1,opt,name=CPU" json:"CPU,omitempty"`
	GPUs    []*GPU   `protobuf:"bytes,2,rep,name=GPUs" json:"GPUs,omitempty"`
	RAM     *RAM     `protobuf:"bytes,3,opt,name=RAM" json:"RAM,omitempty"`
	Network *Network `protobuf:"bytes,4,opt,name=network" json:"network,omitempty"`
	Storage *Storage `protobuf:"bytes,5,opt,name=storage" json:"storage,omitempty"`
}

func (m *DevicesReply) Reset()                    { *m = DevicesReply{} }
func (m *DevicesReply) String() string            { return proto.CompactTextString(m) }
func (*DevicesReply) ProtoMessage()               {}
func (*DevicesReply) Descriptor() ([]byte, []int) { return fileDescriptor16, []int{8} }

func (m *DevicesReply) GetCPU() *CPU {
	if m != nil {
		return m.CPU
	}
	return nil
}

func (m *DevicesReply) GetGPUs() []*GPU {
	if m != nil {
		return m.GPUs
	}
	return nil
}

func (m *DevicesReply) GetRAM() *RAM {
	if m != nil {
		return m.RAM
	}
	return nil
}

func (m *DevicesReply) GetNetwork() *Network {
	if m != nil {
		return m.Network
	}
	return nil
}

func (m *DevicesReply) GetStorage() *Storage {
	if m != nil {
		return m.Storage
	}
	return nil
}

type PullTaskRequest struct {
	DealId string `protobuf:"bytes,1,opt,name=dealId" json:"dealId,omitempty"`
	TaskId string `protobuf:"bytes,2,opt,name=taskId" json:"taskId,omitempty"`
}

func (m *PullTaskRequest) Reset()                    { *m = PullTaskRequest{} }
func (m *PullTaskRequest) String() string            { return proto.CompactTextString(m) }
func (*PullTaskRequest) ProtoMessage()               {}
func (*PullTaskRequest) Descriptor() ([]byte, []int) { return fileDescriptor16, []int{9} }

func (m *PullTaskRequest) GetDealId() string {
	if m != nil {
		return m.DealId
	}
	return ""
}

func (m *PullTaskRequest) GetTaskId() string {
	if m != nil {
		return m.TaskId
	}
	return ""
}

type DealInfoReply struct {
	Deal *Deal `protobuf:"bytes,1,opt,name=deal" json:"deal,omitempty"`
	// List of currently running tasks.
	Running map[string]*TaskStatusReply `protobuf:"bytes,2,rep,name=running" json:"running,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// List of completed tasks.
	Completed map[string]*TaskStatusReply `protobuf:"bytes,3,rep,name=completed" json:"completed,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Resources is a real resources (cores, ram bytes, GPU devices, etc)
	// allocated on a worker for this deal.
	Resources *AskPlanResources `protobuf:"bytes,4,opt,name=resources" json:"resources,omitempty"`
	PublicIPs []string          `protobuf:"bytes,5,rep,name=publicIPs" json:"publicIPs,omitempty"`
}

func (m *DealInfoReply) Reset()                    { *m = DealInfoReply{} }
func (m *DealInfoReply) String() string            { return proto.CompactTextString(m) }
func (*DealInfoReply) ProtoMessage()               {}
func (*DealInfoReply) Descriptor() ([]byte, []int) { return fileDescriptor16, []int{10} }

func (m *DealInfoReply) GetDeal() *Deal {
	if m != nil {
		return m.Deal
	}
	return nil
}

func (m *DealInfoReply) GetRunning() map[string]*TaskStatusReply {
	if m != nil {
		return m.Running
	}
	return nil
}

func (m *DealInfoReply) GetCompleted() map[string]*TaskStatusReply {
	if m != nil {
		return m.Completed
	}
	return nil
}

func (m *DealInfoReply) GetResources() *AskPlanResources {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *DealInfoReply) GetPublicIPs() []string {
	if m != nil {
		return m.PublicIPs
	}
	return nil
}

type TaskStatusReply struct {
	Status    TaskStatusReply_Status `protobuf:"varint,1,opt,name=status,enum=sonm.TaskStatusReply_Status" json:"status,omitempty"`
	ImageName string                 `protobuf:"bytes,2,opt,name=imageName" json:"imageName,omitempty"`
	PortMap   map[string]*Endpoints  `protobuf:"bytes,3,rep,name=portMap" json:"portMap,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Uptime    uint64                 `protobuf:"varint,4,opt,name=uptime" json:"uptime,omitempty"`
	Usage     *ResourceUsage         `protobuf:"bytes,5,opt,name=usage" json:"usage,omitempty"`
	// TODO: looks like we need to use TaskSpec here
	AllocatedResources *AskPlanResources `protobuf:"bytes,6,opt,name=allocatedResources" json:"allocatedResources,omitempty"`
	Tag                *TaskTag          `protobuf:"bytes,7,opt,name=tag" json:"tag,omitempty"`
}

func (m *TaskStatusReply) Reset()                    { *m = TaskStatusReply{} }
func (m *TaskStatusReply) String() string            { return proto.CompactTextString(m) }
func (*TaskStatusReply) ProtoMessage()               {}
func (*TaskStatusReply) Descriptor() ([]byte, []int) { return fileDescriptor16, []int{11} }

func (m *TaskStatusReply) GetStatus() TaskStatusReply_Status {
	if m != nil {
		return m.Status
	}
	return TaskStatusReply_UNKNOWN
}

func (m *TaskStatusReply) GetImageName() string {
	if m != nil {
		return m.ImageName
	}
	return ""
}

func (m *TaskStatusReply) GetPortMap() map[string]*Endpoints {
	if m != nil {
		return m.PortMap
	}
	return nil
}

func (m *TaskStatusReply) GetUptime() uint64 {
	if m != nil {
		return m.Uptime
	}
	return 0
}

func (m *TaskStatusReply) GetUsage() *ResourceUsage {
	if m != nil {
		return m.Usage
	}
	return nil
}

func (m *TaskStatusReply) GetAllocatedResources() *AskPlanResources {
	if m != nil {
		return m.AllocatedResources
	}
	return nil
}

func (m *TaskStatusReply) GetTag() *TaskTag {
	if m != nil {
		return m.Tag
	}
	return nil
}

type TaskPool struct {
	All  *AskPlanResources            `protobuf:"bytes,1,opt,name=all" json:"all,omitempty"`
	Used map[string]*AskPlanResources `protobuf:"bytes,2,rep,name=used" json:"used,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *TaskPool) Reset()                    { *m = TaskPool{} }
func (m *TaskPool) String() string            { return proto.CompactTextString(m) }
func (*TaskPool) ProtoMessage()               {}
func (*TaskPool) Descriptor() ([]byte, []int) { return fileDescriptor16, []int{12} }

func (m *TaskPool) GetAll() *AskPlanResources {
	if m != nil {
		return m.All
	}
	return nil
}

func (m *TaskPool) GetUsed() map[string]*AskPlanResources {
	if m != nil {
		return m.Used
	}
	return nil
}

type AskPlanPool struct {
	All          *AskPlanResources   `protobuf:"bytes,1,opt,name=all" json:"all,omitempty"`
	UsedSpot     map[string]*AskPlan `protobuf:"bytes,2,rep,name=usedSpot" json:"usedSpot,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	UsedFw       map[string]*AskPlan `protobuf:"bytes,3,rep,name=usedFw" json:"usedFw,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	CommitedSpot map[string]*AskPlan `protobuf:"bytes,4,rep,name=commitedSpot" json:"commitedSpot,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	CommitedFw   map[string]*AskPlan `protobuf:"bytes,5,rep,name=commitedFw" json:"commitedFw,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	EjectedPlans map[string]*AskPlan `protobuf:"bytes,6,rep,name=ejectedPlans" json:"ejectedPlans,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *AskPlanPool) Reset()                    { *m = AskPlanPool{} }
func (m *AskPlanPool) String() string            { return proto.CompactTextString(m) }
func (*AskPlanPool) ProtoMessage()               {}
func (*AskPlanPool) Descriptor() ([]byte, []int) { return fileDescriptor16, []int{13} }

func (m *AskPlanPool) GetAll() *AskPlanResources {
	if m != nil {
		return m.All
	}
	return nil
}

func (m *AskPlanPool) GetUsedSpot() map[string]*AskPlan {
	if m != nil {
		return m.UsedSpot
	}
	return nil
}

func (m *AskPlanPool) GetUsedFw() map[string]*AskPlan {
	if m != nil {
		return m.UsedFw
	}
	return nil
}

func (m *AskPlanPool) GetCommitedSpot() map[string]*AskPlan {
	if m != nil {
		return m.CommitedSpot
	}
	return nil
}

func (m *AskPlanPool) GetCommitedFw() map[string]*AskPlan {
	if m != nil {
		return m.CommitedFw
	}
	return nil
}

func (m *AskPlanPool) GetEjectedPlans() map[string]*AskPlan {
	if m != nil {
		return m.EjectedPlans
	}
	return nil
}

type SchedulerData struct {
	TaskToAskPlan map[string]string    `protobuf:"bytes,1,rep,name=taskToAskPlan" json:"taskToAskPlan,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	AskPlanPools  map[string]*TaskPool `protobuf:"bytes,3,rep,name=askPlanPools" json:"askPlanPools,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	PlanPool      *AskPlanPool         `protobuf:"bytes,4,opt,name=planPool" json:"planPool,omitempty"`
}

func (m *SchedulerData) Reset()                    { *m = SchedulerData{} }
func (m *SchedulerData) String() string            { return proto.CompactTextString(m) }
func (*SchedulerData) ProtoMessage()               {}
func (*SchedulerData) Descriptor() ([]byte, []int) { return fileDescriptor16, []int{14} }

func (m *SchedulerData) GetTaskToAskPlan() map[string]string {
	if m != nil {
		return m.TaskToAskPlan
	}
	return nil
}

func (m *SchedulerData) GetAskPlanPools() map[string]*TaskPool {
	if m != nil {
		return m.AskPlanPools
	}
	return nil
}

func (m *SchedulerData) GetPlanPool() *AskPlanPool {
	if m != nil {
		return m.PlanPool
	}
	return nil
}

type SalesmanData struct {
	AskPlanCGroups map[string]string `protobuf:"bytes,2,rep,name=askPlanCGroups" json:"askPlanCGroups,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Deals          map[string]*Deal  `protobuf:"bytes,3,rep,name=deals" json:"deals,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Orders         map[string]*Order `protobuf:"bytes,4,rep,name=orders" json:"orders,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *SalesmanData) Reset()                    { *m = SalesmanData{} }
func (m *SalesmanData) String() string            { return proto.CompactTextString(m) }
func (*SalesmanData) ProtoMessage()               {}
func (*SalesmanData) Descriptor() ([]byte, []int) { return fileDescriptor16, []int{15} }

func (m *SalesmanData) GetAskPlanCGroups() map[string]string {
	if m != nil {
		return m.AskPlanCGroups
	}
	return nil
}

func (m *SalesmanData) GetDeals() map[string]*Deal {
	if m != nil {
		return m.Deals
	}
	return nil
}

func (m *SalesmanData) GetOrders() map[string]*Order {
	if m != nil {
		return m.Orders
	}
	return nil
}

type DebugStateReply struct {
	SchedulerData *SchedulerData `protobuf:"bytes,1,opt,name=schedulerData" json:"schedulerData,omitempty"`
	SalesmanData  *SalesmanData  `protobuf:"bytes,2,opt,name=salesmanData" json:"salesmanData,omitempty"`
}

func (m *DebugStateReply) Reset()                    { *m = DebugStateReply{} }
func (m *DebugStateReply) String() string            { return proto.CompactTextString(m) }
func (*DebugStateReply) ProtoMessage()               {}
func (*DebugStateReply) Descriptor() ([]byte, []int) { return fileDescriptor16, []int{16} }

func (m *DebugStateReply) GetSchedulerData() *SchedulerData {
	if m != nil {
		return m.SchedulerData
	}
	return nil
}

func (m *DebugStateReply) GetSalesmanData() *SalesmanData {
	if m != nil {
		return m.SalesmanData
	}
	return nil
}

type PurgeTasksRequest struct {
	DealID *BigInt `protobuf:"bytes,1,opt,name=dealID" json:"dealID,omitempty"`
}

func (m *PurgeTasksRequest) Reset()                    { *m = PurgeTasksRequest{} }
func (m *PurgeTasksRequest) String() string            { return proto.CompactTextString(m) }
func (*PurgeTasksRequest) ProtoMessage()               {}
func (*PurgeTasksRequest) Descriptor() ([]byte, []int) { return fileDescriptor16, []int{17} }

func (m *PurgeTasksRequest) GetDealID() *BigInt {
	if m != nil {
		return m.DealID
	}
	return nil
}

type WorkerMetricsRequest struct {
}

func (m *WorkerMetricsRequest) Reset()                    { *m = WorkerMetricsRequest{} }
func (m *WorkerMetricsRequest) String() string            { return proto.CompactTextString(m) }
func (*WorkerMetricsRequest) ProtoMessage()               {}
func (*WorkerMetricsRequest) Descriptor() ([]byte, []int) { return fileDescriptor16, []int{18} }

type WorkerMetricsResponse struct {
	Metrics map[string]float64 `protobuf:"bytes,1,rep,name=metrics" json:"metrics,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"fixed64,2,opt,name=value"`
}

func (m *WorkerMetricsResponse) Reset()                    { *m = WorkerMetricsResponse{} }
func (m *WorkerMetricsResponse) String() string            { return proto.CompactTextString(m) }
func (*WorkerMetricsResponse) ProtoMessage()               {}
func (*WorkerMetricsResponse) Descriptor() ([]byte, []int) { return fileDescriptor16, []int{19} }

func (m *WorkerMetricsResponse) GetMetrics() map[string]float64 {
	if m != nil {
		return m.Metrics
	}
	return nil
}

func init() {
	proto.RegisterType((*TaskTag)(nil), "sonm.TaskTag")
	proto.RegisterType((*TaskSpec)(nil), "sonm.TaskSpec")
	proto.RegisterType((*StartTaskRequest)(nil), "sonm.StartTaskRequest")
	proto.RegisterType((*WorkerJoinNetworkRequest)(nil), "sonm.WorkerJoinNetworkRequest")
	proto.RegisterType((*StartTaskReply)(nil), "sonm.StartTaskReply")
	proto.RegisterType((*StatusReply)(nil), "sonm.StatusReply")
	proto.RegisterType((*AskPlansReply)(nil), "sonm.AskPlansReply")
	proto.RegisterType((*TaskListReply)(nil), "sonm.TaskListReply")
	proto.RegisterType((*DevicesReply)(nil), "sonm.DevicesReply")
	proto.RegisterType((*PullTaskRequest)(nil), "sonm.PullTaskRequest")
	proto.RegisterType((*DealInfoReply)(nil), "sonm.DealInfoReply")
	proto.RegisterType((*TaskStatusReply)(nil), "sonm.TaskStatusReply")
	proto.RegisterType((*TaskPool)(nil), "sonm.TaskPool")
	proto.RegisterType((*AskPlanPool)(nil), "sonm.AskPlanPool")
	proto.RegisterType((*SchedulerData)(nil), "sonm.SchedulerData")
	proto.RegisterType((*SalesmanData)(nil), "sonm.SalesmanData")
	proto.RegisterType((*DebugStateReply)(nil), "sonm.DebugStateReply")
	proto.RegisterType((*PurgeTasksRequest)(nil), "sonm.PurgeTasksRequest")
	proto.RegisterType((*WorkerMetricsRequest)(nil), "sonm.WorkerMetricsRequest")
	proto.RegisterType((*WorkerMetricsResponse)(nil), "sonm.WorkerMetricsResponse")
	proto.RegisterEnum("sonm.TaskStatusReply_Status", TaskStatusReply_Status_name, TaskStatusReply_Status_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for WorkerManagement service

type WorkerManagementClient interface {
	// Status produse a detailed info about worker
	Status(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*StatusReply, error)
	// Devices provides detailed information about device
	// and show benchmark results.
	Devices(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*DevicesReply, error)
	// FreeDevices provides information about unallocated resources
	// that can be turned into ask-plans.
	// Deprecated: no longer usable.
	FreeDevices(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*DevicesReply, error)
	// Tasks produces a list of all running tasks on the worker
	Tasks(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*TaskListReply, error)
	// AskPlans allows to obtain previously assigned Ask Plans from for a given worker.
	AskPlans(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*AskPlansReply, error)
	// CreateAskPlan allows to create rules
	// for creating Ask orders on Marketplace
	CreateAskPlan(ctx context.Context, in *AskPlan, opts ...grpc.CallOption) (*ID, error)
	// RemoveAskPlan allows to remove rules
	// for creating Ask orders on Marketplace
	RemoveAskPlan(ctx context.Context, in *ID, opts ...grpc.CallOption) (*Empty, error)
	// PurgeAskPlans removes all ask-plans
	// Deprecated: use PurgeAsksPlansDetailed instead
	PurgeAskPlans(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	// PurgeAsksPlansDetailed removes all ask-plans in sync manner and returns error for each ask-plan (if it's present)
	PurgeAskPlansDetailed(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ErrorByStringID, error)
	// Schedule maintenance for worker: it will attempt to close all deals till that time point
	ScheduleMaintenance(ctx context.Context, in *Timestamp, opts ...grpc.CallOption) (*Empty, error)
	// Get next planned maintenance
	NextMaintenance(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Timestamp, error)
	// Get useful debugging info - scheduler state and salesman state
	DebugState(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*DebugStateReply, error)
	// Remove benchmark cached value by specified benchmark ID
	RemoveBenchmark(ctx context.Context, in *NumericID, opts ...grpc.CallOption) (*Empty, error)
	// Schedule full rebenchmarking on next restart
	PurgeBenchmarks(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	// Metrics returns hardware metrics for this worker.
	Metrics(ctx context.Context, in *WorkerMetricsRequest, opts ...grpc.CallOption) (*WorkerMetricsResponse, error)
}

type workerManagementClient struct {
	cc *grpc.ClientConn
}

func NewWorkerManagementClient(cc *grpc.ClientConn) WorkerManagementClient {
	return &workerManagementClient{cc}
}

func (c *workerManagementClient) Status(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*StatusReply, error) {
	out := new(StatusReply)
	err := grpc.Invoke(ctx, "/sonm.WorkerManagement/Status", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerManagementClient) Devices(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*DevicesReply, error) {
	out := new(DevicesReply)
	err := grpc.Invoke(ctx, "/sonm.WorkerManagement/Devices", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerManagementClient) FreeDevices(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*DevicesReply, error) {
	out := new(DevicesReply)
	err := grpc.Invoke(ctx, "/sonm.WorkerManagement/FreeDevices", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerManagementClient) Tasks(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*TaskListReply, error) {
	out := new(TaskListReply)
	err := grpc.Invoke(ctx, "/sonm.WorkerManagement/Tasks", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerManagementClient) AskPlans(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*AskPlansReply, error) {
	out := new(AskPlansReply)
	err := grpc.Invoke(ctx, "/sonm.WorkerManagement/AskPlans", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerManagementClient) CreateAskPlan(ctx context.Context, in *AskPlan, opts ...grpc.CallOption) (*ID, error) {
	out := new(ID)
	err := grpc.Invoke(ctx, "/sonm.WorkerManagement/CreateAskPlan", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerManagementClient) RemoveAskPlan(ctx context.Context, in *ID, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/sonm.WorkerManagement/RemoveAskPlan", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerManagementClient) PurgeAskPlans(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/sonm.WorkerManagement/PurgeAskPlans", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerManagementClient) PurgeAskPlansDetailed(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ErrorByStringID, error) {
	out := new(ErrorByStringID)
	err := grpc.Invoke(ctx, "/sonm.WorkerManagement/PurgeAskPlansDetailed", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerManagementClient) ScheduleMaintenance(ctx context.Context, in *Timestamp, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/sonm.WorkerManagement/ScheduleMaintenance", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerManagementClient) NextMaintenance(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Timestamp, error) {
	out := new(Timestamp)
	err := grpc.Invoke(ctx, "/sonm.WorkerManagement/NextMaintenance", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerManagementClient) DebugState(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*DebugStateReply, error) {
	out := new(DebugStateReply)
	err := grpc.Invoke(ctx, "/sonm.WorkerManagement/DebugState", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerManagementClient) RemoveBenchmark(ctx context.Context, in *NumericID, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/sonm.WorkerManagement/RemoveBenchmark", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerManagementClient) PurgeBenchmarks(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/sonm.WorkerManagement/PurgeBenchmarks", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerManagementClient) Metrics(ctx context.Context, in *WorkerMetricsRequest, opts ...grpc.CallOption) (*WorkerMetricsResponse, error) {
	out := new(WorkerMetricsResponse)
	err := grpc.Invoke(ctx, "/sonm.WorkerManagement/Metrics", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for WorkerManagement service

type WorkerManagementServer interface {
	// Status produse a detailed info about worker
	Status(context.Context, *Empty) (*StatusReply, error)
	// Devices provides detailed information about device
	// and show benchmark results.
	Devices(context.Context, *Empty) (*DevicesReply, error)
	// FreeDevices provides information about unallocated resources
	// that can be turned into ask-plans.
	// Deprecated: no longer usable.
	FreeDevices(context.Context, *Empty) (*DevicesReply, error)
	// Tasks produces a list of all running tasks on the worker
	Tasks(context.Context, *Empty) (*TaskListReply, error)
	// AskPlans allows to obtain previously assigned Ask Plans from for a given worker.
	AskPlans(context.Context, *Empty) (*AskPlansReply, error)
	// CreateAskPlan allows to create rules
	// for creating Ask orders on Marketplace
	CreateAskPlan(context.Context, *AskPlan) (*ID, error)
	// RemoveAskPlan allows to remove rules
	// for creating Ask orders on Marketplace
	RemoveAskPlan(context.Context, *ID) (*Empty, error)
	// PurgeAskPlans removes all ask-plans
	// Deprecated: use PurgeAsksPlansDetailed instead
	PurgeAskPlans(context.Context, *Empty) (*Empty, error)
	// PurgeAsksPlansDetailed removes all ask-plans in sync manner and returns error for each ask-plan (if it's present)
	PurgeAskPlansDetailed(context.Context, *Empty) (*ErrorByStringID, error)
	// Schedule maintenance for worker: it will attempt to close all deals till that time point
	ScheduleMaintenance(context.Context, *Timestamp) (*Empty, error)
	// Get next planned maintenance
	NextMaintenance(context.Context, *Empty) (*Timestamp, error)
	// Get useful debugging info - scheduler state and salesman state
	DebugState(context.Context, *Empty) (*DebugStateReply, error)
	// Remove benchmark cached value by specified benchmark ID
	RemoveBenchmark(context.Context, *NumericID) (*Empty, error)
	// Schedule full rebenchmarking on next restart
	PurgeBenchmarks(context.Context, *Empty) (*Empty, error)
	// Metrics returns hardware metrics for this worker.
	Metrics(context.Context, *WorkerMetricsRequest) (*WorkerMetricsResponse, error)
}

func RegisterWorkerManagementServer(s *grpc.Server, srv WorkerManagementServer) {
	s.RegisterService(&_WorkerManagement_serviceDesc, srv)
}

func _WorkerManagement_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerManagementServer).Status(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.WorkerManagement/Status",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerManagementServer).Status(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerManagement_Devices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerManagementServer).Devices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.WorkerManagement/Devices",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerManagementServer).Devices(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerManagement_FreeDevices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerManagementServer).FreeDevices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.WorkerManagement/FreeDevices",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerManagementServer).FreeDevices(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerManagement_Tasks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerManagementServer).Tasks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.WorkerManagement/Tasks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerManagementServer).Tasks(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerManagement_AskPlans_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerManagementServer).AskPlans(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.WorkerManagement/AskPlans",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerManagementServer).AskPlans(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerManagement_CreateAskPlan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AskPlan)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerManagementServer).CreateAskPlan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.WorkerManagement/CreateAskPlan",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerManagementServer).CreateAskPlan(ctx, req.(*AskPlan))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerManagement_RemoveAskPlan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerManagementServer).RemoveAskPlan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.WorkerManagement/RemoveAskPlan",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerManagementServer).RemoveAskPlan(ctx, req.(*ID))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerManagement_PurgeAskPlans_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerManagementServer).PurgeAskPlans(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.WorkerManagement/PurgeAskPlans",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerManagementServer).PurgeAskPlans(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerManagement_PurgeAskPlansDetailed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerManagementServer).PurgeAskPlansDetailed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.WorkerManagement/PurgeAskPlansDetailed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerManagementServer).PurgeAskPlansDetailed(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerManagement_ScheduleMaintenance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Timestamp)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerManagementServer).ScheduleMaintenance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.WorkerManagement/ScheduleMaintenance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerManagementServer).ScheduleMaintenance(ctx, req.(*Timestamp))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerManagement_NextMaintenance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerManagementServer).NextMaintenance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.WorkerManagement/NextMaintenance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerManagementServer).NextMaintenance(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerManagement_DebugState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerManagementServer).DebugState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.WorkerManagement/DebugState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerManagementServer).DebugState(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerManagement_RemoveBenchmark_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NumericID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerManagementServer).RemoveBenchmark(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.WorkerManagement/RemoveBenchmark",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerManagementServer).RemoveBenchmark(ctx, req.(*NumericID))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerManagement_PurgeBenchmarks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerManagementServer).PurgeBenchmarks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.WorkerManagement/PurgeBenchmarks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerManagementServer).PurgeBenchmarks(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerManagement_Metrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkerMetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerManagementServer).Metrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.WorkerManagement/Metrics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerManagementServer).Metrics(ctx, req.(*WorkerMetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _WorkerManagement_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sonm.WorkerManagement",
	HandlerType: (*WorkerManagementServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Status",
			Handler:    _WorkerManagement_Status_Handler,
		},
		{
			MethodName: "Devices",
			Handler:    _WorkerManagement_Devices_Handler,
		},
		{
			MethodName: "FreeDevices",
			Handler:    _WorkerManagement_FreeDevices_Handler,
		},
		{
			MethodName: "Tasks",
			Handler:    _WorkerManagement_Tasks_Handler,
		},
		{
			MethodName: "AskPlans",
			Handler:    _WorkerManagement_AskPlans_Handler,
		},
		{
			MethodName: "CreateAskPlan",
			Handler:    _WorkerManagement_CreateAskPlan_Handler,
		},
		{
			MethodName: "RemoveAskPlan",
			Handler:    _WorkerManagement_RemoveAskPlan_Handler,
		},
		{
			MethodName: "PurgeAskPlans",
			Handler:    _WorkerManagement_PurgeAskPlans_Handler,
		},
		{
			MethodName: "PurgeAskPlansDetailed",
			Handler:    _WorkerManagement_PurgeAskPlansDetailed_Handler,
		},
		{
			MethodName: "ScheduleMaintenance",
			Handler:    _WorkerManagement_ScheduleMaintenance_Handler,
		},
		{
			MethodName: "NextMaintenance",
			Handler:    _WorkerManagement_NextMaintenance_Handler,
		},
		{
			MethodName: "DebugState",
			Handler:    _WorkerManagement_DebugState_Handler,
		},
		{
			MethodName: "RemoveBenchmark",
			Handler:    _WorkerManagement_RemoveBenchmark_Handler,
		},
		{
			MethodName: "PurgeBenchmarks",
			Handler:    _WorkerManagement_PurgeBenchmarks_Handler,
		},
		{
			MethodName: "Metrics",
			Handler:    _WorkerManagement_Metrics_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "worker.proto",
}

// Client API for Worker service

type WorkerClient interface {
	PushTask(ctx context.Context, opts ...grpc.CallOption) (Worker_PushTaskClient, error)
	PullTask(ctx context.Context, in *PullTaskRequest, opts ...grpc.CallOption) (Worker_PullTaskClient, error)
	// StartTask schedules the task associcated with a deal.
	StartTask(ctx context.Context, in *StartTaskRequest, opts ...grpc.CallOption) (*StartTaskReply, error)
	StopTask(ctx context.Context, in *ID, opts ...grpc.CallOption) (*Empty, error)
	// PurgeTasks stops all tasks by given deal
	PurgeTasks(ctx context.Context, in *PurgeTasksRequest, opts ...grpc.CallOption) (*ErrorByStringID, error)
	TaskStatus(ctx context.Context, in *ID, opts ...grpc.CallOption) (*TaskStatusReply, error)
	JoinNetwork(ctx context.Context, in *WorkerJoinNetworkRequest, opts ...grpc.CallOption) (*NetworkSpec, error)
	TaskLogs(ctx context.Context, in *TaskLogsRequest, opts ...grpc.CallOption) (Worker_TaskLogsClient, error)
	// Note: currently used for testing pusposes.
	GetDealInfo(ctx context.Context, in *ID, opts ...grpc.CallOption) (*DealInfoReply, error)
}

type workerClient struct {
	cc *grpc.ClientConn
}

func NewWorkerClient(cc *grpc.ClientConn) WorkerClient {
	return &workerClient{cc}
}

func (c *workerClient) PushTask(ctx context.Context, opts ...grpc.CallOption) (Worker_PushTaskClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Worker_serviceDesc.Streams[0], c.cc, "/sonm.Worker/PushTask", opts...)
	if err != nil {
		return nil, err
	}
	x := &workerPushTaskClient{stream}
	return x, nil
}

type Worker_PushTaskClient interface {
	Send(*Chunk) error
	Recv() (*Progress, error)
	grpc.ClientStream
}

type workerPushTaskClient struct {
	grpc.ClientStream
}

func (x *workerPushTaskClient) Send(m *Chunk) error {
	return x.ClientStream.SendMsg(m)
}

func (x *workerPushTaskClient) Recv() (*Progress, error) {
	m := new(Progress)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *workerClient) PullTask(ctx context.Context, in *PullTaskRequest, opts ...grpc.CallOption) (Worker_PullTaskClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Worker_serviceDesc.Streams[1], c.cc, "/sonm.Worker/PullTask", opts...)
	if err != nil {
		return nil, err
	}
	x := &workerPullTaskClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Worker_PullTaskClient interface {
	Recv() (*Chunk, error)
	grpc.ClientStream
}

type workerPullTaskClient struct {
	grpc.ClientStream
}

func (x *workerPullTaskClient) Recv() (*Chunk, error) {
	m := new(Chunk)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *workerClient) StartTask(ctx context.Context, in *StartTaskRequest, opts ...grpc.CallOption) (*StartTaskReply, error) {
	out := new(StartTaskReply)
	err := grpc.Invoke(ctx, "/sonm.Worker/StartTask", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) StopTask(ctx context.Context, in *ID, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/sonm.Worker/StopTask", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) PurgeTasks(ctx context.Context, in *PurgeTasksRequest, opts ...grpc.CallOption) (*ErrorByStringID, error) {
	out := new(ErrorByStringID)
	err := grpc.Invoke(ctx, "/sonm.Worker/PurgeTasks", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) TaskStatus(ctx context.Context, in *ID, opts ...grpc.CallOption) (*TaskStatusReply, error) {
	out := new(TaskStatusReply)
	err := grpc.Invoke(ctx, "/sonm.Worker/TaskStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) JoinNetwork(ctx context.Context, in *WorkerJoinNetworkRequest, opts ...grpc.CallOption) (*NetworkSpec, error) {
	out := new(NetworkSpec)
	err := grpc.Invoke(ctx, "/sonm.Worker/JoinNetwork", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) TaskLogs(ctx context.Context, in *TaskLogsRequest, opts ...grpc.CallOption) (Worker_TaskLogsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Worker_serviceDesc.Streams[2], c.cc, "/sonm.Worker/TaskLogs", opts...)
	if err != nil {
		return nil, err
	}
	x := &workerTaskLogsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Worker_TaskLogsClient interface {
	Recv() (*TaskLogsChunk, error)
	grpc.ClientStream
}

type workerTaskLogsClient struct {
	grpc.ClientStream
}

func (x *workerTaskLogsClient) Recv() (*TaskLogsChunk, error) {
	m := new(TaskLogsChunk)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *workerClient) GetDealInfo(ctx context.Context, in *ID, opts ...grpc.CallOption) (*DealInfoReply, error) {
	out := new(DealInfoReply)
	err := grpc.Invoke(ctx, "/sonm.Worker/GetDealInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Worker service

type WorkerServer interface {
	PushTask(Worker_PushTaskServer) error
	PullTask(*PullTaskRequest, Worker_PullTaskServer) error
	// StartTask schedules the task associcated with a deal.
	StartTask(context.Context, *StartTaskRequest) (*StartTaskReply, error)
	StopTask(context.Context, *ID) (*Empty, error)
	// PurgeTasks stops all tasks by given deal
	PurgeTasks(context.Context, *PurgeTasksRequest) (*ErrorByStringID, error)
	TaskStatus(context.Context, *ID) (*TaskStatusReply, error)
	JoinNetwork(context.Context, *WorkerJoinNetworkRequest) (*NetworkSpec, error)
	TaskLogs(*TaskLogsRequest, Worker_TaskLogsServer) error
	// Note: currently used for testing pusposes.
	GetDealInfo(context.Context, *ID) (*DealInfoReply, error)
}

func RegisterWorkerServer(s *grpc.Server, srv WorkerServer) {
	s.RegisterService(&_Worker_serviceDesc, srv)
}

func _Worker_PushTask_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(WorkerServer).PushTask(&workerPushTaskServer{stream})
}

type Worker_PushTaskServer interface {
	Send(*Progress) error
	Recv() (*Chunk, error)
	grpc.ServerStream
}

type workerPushTaskServer struct {
	grpc.ServerStream
}

func (x *workerPushTaskServer) Send(m *Progress) error {
	return x.ServerStream.SendMsg(m)
}

func (x *workerPushTaskServer) Recv() (*Chunk, error) {
	m := new(Chunk)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Worker_PullTask_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PullTaskRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(WorkerServer).PullTask(m, &workerPullTaskServer{stream})
}

type Worker_PullTaskServer interface {
	Send(*Chunk) error
	grpc.ServerStream
}

type workerPullTaskServer struct {
	grpc.ServerStream
}

func (x *workerPullTaskServer) Send(m *Chunk) error {
	return x.ServerStream.SendMsg(m)
}

func _Worker_StartTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).StartTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.Worker/StartTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).StartTask(ctx, req.(*StartTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_StopTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).StopTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.Worker/StopTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).StopTask(ctx, req.(*ID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_PurgeTasks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PurgeTasksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).PurgeTasks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.Worker/PurgeTasks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).PurgeTasks(ctx, req.(*PurgeTasksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_TaskStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).TaskStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.Worker/TaskStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).TaskStatus(ctx, req.(*ID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_JoinNetwork_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkerJoinNetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).JoinNetwork(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.Worker/JoinNetwork",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).JoinNetwork(ctx, req.(*WorkerJoinNetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_TaskLogs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TaskLogsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(WorkerServer).TaskLogs(m, &workerTaskLogsServer{stream})
}

type Worker_TaskLogsServer interface {
	Send(*TaskLogsChunk) error
	grpc.ServerStream
}

type workerTaskLogsServer struct {
	grpc.ServerStream
}

func (x *workerTaskLogsServer) Send(m *TaskLogsChunk) error {
	return x.ServerStream.SendMsg(m)
}

func _Worker_GetDealInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).GetDealInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.Worker/GetDealInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).GetDealInfo(ctx, req.(*ID))
	}
	return interceptor(ctx, in, info, handler)
}

var _Worker_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sonm.Worker",
	HandlerType: (*WorkerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StartTask",
			Handler:    _Worker_StartTask_Handler,
		},
		{
			MethodName: "StopTask",
			Handler:    _Worker_StopTask_Handler,
		},
		{
			MethodName: "PurgeTasks",
			Handler:    _Worker_PurgeTasks_Handler,
		},
		{
			MethodName: "TaskStatus",
			Handler:    _Worker_TaskStatus_Handler,
		},
		{
			MethodName: "JoinNetwork",
			Handler:    _Worker_JoinNetwork_Handler,
		},
		{
			MethodName: "GetDealInfo",
			Handler:    _Worker_GetDealInfo_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "PushTask",
			Handler:       _Worker_PushTask_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "PullTask",
			Handler:       _Worker_PullTask_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "TaskLogs",
			Handler:       _Worker_TaskLogs_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "worker.proto",
}

func init() { proto.RegisterFile("worker.proto", fileDescriptor16) }

var fileDescriptor16 = []byte{
	// 2071 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0xcd, 0x72, 0x1b, 0xb9,
	0xf1, 0x27, 0x45, 0x8a, 0x1f, 0x4d, 0x52, 0xa2, 0x20, 0x5b, 0x7f, 0xd6, 0xac, 0xed, 0xd5, 0x8e,
	0x77, 0xf7, 0xcf, 0x78, 0x6d, 0xc6, 0xab, 0xfd, 0xa8, 0xac, 0x9d, 0x4d, 0xad, 0x24, 0x4a, 0x32,
	0x6d, 0x8b, 0x62, 0x86, 0x56, 0x39, 0x87, 0x54, 0xa5, 0x60, 0x12, 0xa2, 0x26, 0x22, 0x67, 0x26,
	0x03, 0x50, 0x8e, 0x72, 0x4d, 0x9e, 0x20, 0x97, 0x54, 0xa5, 0xf2, 0x02, 0xb9, 0xe4, 0x92, 0x53,
	0xaa, 0xf2, 0x04, 0x79, 0x98, 0x54, 0x4e, 0x39, 0xa7, 0x00, 0x34, 0xe6, 0x83, 0x1c, 0x6d, 0xe2,
	0x92, 0x6f, 0x83, 0xee, 0xdf, 0xaf, 0xd1, 0xd3, 0x68, 0x74, 0x03, 0x80, 0xfa, 0x5b, 0x3f, 0xbc,
	0x60, 0x61, 0x27, 0x08, 0x7d, 0xe1, 0x93, 0x22, 0xf7, 0xbd, 0x99, 0xb5, 0x46, 0xf9, 0xc5, 0x2f,
	0x82, 0x29, 0xf5, 0xb4, 0xd4, 0xaa, 0xbf, 0x71, 0x27, 0xae, 0x27, 0x70, 0x44, 0x46, 0x34, 0xa0,
	0x6f, 0xdc, 0xa9, 0x2b, 0x5c, 0xc6, 0x51, 0xb6, 0x3e, 0xf2, 0x3d, 0x41, 0x5d, 0xcf, 0x18, 0xb2,
	0x6a, 0x13, 0xe6, 0xbb, 0x81, 0xd1, 0xba, 0x9e, 0xb4, 0xeb, 0xb9, 0x14, 0x05, 0x1b, 0x33, 0x1a,
	0x5e, 0x30, 0x11, 0x4c, 0xe9, 0x88, 0xa1, 0xa8, 0xea, 0x31, 0x33, 0xc1, 0xba, 0x70, 0x67, 0x8c,
	0x0b, 0x3a, 0x43, 0xbe, 0x7d, 0x17, 0xca, 0xaf, 0x28, 0xbf, 0x78, 0x45, 0x27, 0x84, 0x40, 0x71,
	0x4c, 0x05, 0x6d, 0xe5, 0xb7, 0xf3, 0xed, 0xba, 0xa3, 0xbe, 0xed, 0xbf, 0xe7, 0xa1, 0x22, 0xf5,
	0xc3, 0x80, 0x8d, 0xc8, 0x23, 0xa8, 0x46, 0xbe, 0x28, 0x54, 0x6d, 0x67, 0xbd, 0x23, 0x67, 0xef,
	0xec, 0x1b, 0xb1, 0x13, 0x23, 0xc8, 0x03, 0xa8, 0x84, 0x6c, 0xe2, 0x72, 0x11, 0x5e, 0xb5, 0x56,
	0x14, 0x7a, 0x4d, 0xa3, 0x1d, 0x94, 0x3a, 0x91, 0x9e, 0x7c, 0x09, 0xd5, 0x90, 0x71, 0x7f, 0x1e,
	0x8e, 0x18, 0x6f, 0x15, 0x14, 0x78, 0x4b, 0x83, 0x77, 0xf9, 0xc5, 0x60, 0x4a, 0x3d, 0xc7, 0x68,
	0x9d, 0x18, 0x48, 0x3e, 0x84, 0x82, 0xa0, 0x93, 0x56, 0x51, 0xe1, 0x1b, 0x1a, 0x8f, 0x7f, 0xe3,
	0x48, 0x8d, 0xfd, 0x73, 0x68, 0x0e, 0x05, 0x0d, 0x85, 0x14, 0x3a, 0xec, 0x57, 0x73, 0xc6, 0x05,
	0xf9, 0x18, 0x4a, 0x63, 0x46, 0xa7, 0xbd, 0x2e, 0xfe, 0x42, 0x5d, 0xf3, 0xf6, 0xdc, 0x49, 0xcf,
	0x13, 0x0e, 0xea, 0x88, 0x0d, 0x45, 0x1e, 0xb0, 0x51, 0xda, 0x71, 0x13, 0x09, 0x47, 0xe9, 0xec,
	0x01, 0xb4, 0x5e, 0xab, 0x15, 0x7e, 0xee, 0xbb, 0x5e, 0x9f, 0x09, 0xb9, 0xdc, 0x66, 0x96, 0x2d,
	0x28, 0x09, 0xca, 0x2f, 0x70, 0x96, 0xaa, 0x83, 0x23, 0x72, 0x07, 0xe4, 0x6a, 0x48, 0x64, 0xaf,
	0xab, 0x8c, 0x57, 0x9d, 0x58, 0x60, 0xff, 0x23, 0x0f, 0x6b, 0x09, 0x87, 0x83, 0xe9, 0x15, 0x59,
	0x83, 0x15, 0x77, 0x8c, 0x46, 0x56, 0xdc, 0x31, 0x79, 0x0a, 0xe5, 0xc0, 0x0f, 0xc5, 0x31, 0x0d,
	0x5a, 0x2b, 0xdb, 0x85, 0x76, 0x6d, 0xe7, 0x23, 0xed, 0x5b, 0x9a, 0xd6, 0x19, 0x68, 0xcc, 0x81,
	0x27, 0xe3, 0x6c, 0x18, 0xe4, 0x1e, 0x40, 0x34, 0x99, 0x8c, 0x73, 0xa1, 0x5d, 0x75, 0x12, 0x12,
	0xeb, 0x05, 0xd4, 0x93, 0x44, 0xd2, 0x84, 0xc2, 0x05, 0xbb, 0xc2, 0xd9, 0xe5, 0x27, 0xf9, 0x04,
	0x56, 0x2f, 0xe9, 0x74, 0xce, 0x30, 0x30, 0xb8, 0xfe, 0x07, 0xde, 0x38, 0xf0, 0x5d, 0x4f, 0x70,
	0x47, 0x6b, 0x9f, 0xac, 0xfc, 0x28, 0x6f, 0xff, 0xa5, 0x00, 0xb5, 0xa1, 0xa0, 0x62, 0xce, 0xf5,
	0x9f, 0x6c, 0x41, 0x69, 0x1e, 0xc8, 0xfc, 0x53, 0xf6, 0x8a, 0x0e, 0x8e, 0x48, 0x0b, 0xca, 0x97,
	0x2c, 0xe4, 0xae, 0xef, 0x61, 0x40, 0xcc, 0x90, 0x58, 0x50, 0x09, 0xa6, 0x54, 0x9c, 0xf9, 0xe1,
	0x4c, 0x25, 0x45, 0xd5, 0x89, 0xc6, 0x92, 0xc5, 0xc4, 0xf9, 0xee, 0x78, 0x1c, 0xaa, 0xf5, 0xaf,
	0x3a, 0x66, 0x28, 0x43, 0x2c, 0x83, 0xbd, 0xef, 0xcf, 0x3d, 0xd1, 0x5a, 0xdd, 0xce, 0xb7, 0x1b,
	0x4e, 0x2c, 0x90, 0xda, 0xee, 0xeb, 0x67, 0xda, 0xaf, 0x56, 0x49, 0x2f, 0x40, 0x24, 0x20, 0x0f,
	0xa0, 0x19, 0x32, 0x6f, 0xcc, 0x7e, 0x73, 0xe9, 0xcf, 0x39, 0x82, 0xca, 0x0a, 0xb4, 0x24, 0x27,
	0x6d, 0x28, 0xcd, 0x28, 0x17, 0x2c, 0x6c, 0x55, 0x54, 0x2c, 0x9a, 0x18, 0x0b, 0xed, 0x06, 0xe3,
	0xdc, 0x41, 0x3d, 0xf9, 0x14, 0x56, 0xe9, 0x78, 0xe6, 0x7a, 0xad, 0xea, 0x35, 0x40, 0xad, 0x26,
	0x0f, 0x61, 0xc3, 0xe5, 0xc7, 0x8a, 0xb3, 0xef, 0x7b, 0x67, 0x6e, 0x38, 0x63, 0xe3, 0x16, 0x6c,
	0xe7, 0xdb, 0x15, 0x67, 0x59, 0x41, 0x1e, 0xc3, 0xa6, 0xcb, 0xf7, 0x98, 0x37, 0x3a, 0x97, 0x5b,
	0xfe, 0xd0, 0xf5, 0x5c, 0x7e, 0xce, 0xc6, 0xad, 0x9a, 0xc2, 0x67, 0xa9, 0xc8, 0x5d, 0x28, 0x4c,
	0x98, 0xdf, 0xaa, 0x2b, 0x2f, 0x6a, 0xda, 0x8b, 0x23, 0xe6, 0xf7, 0x06, 0x8e, 0x94, 0xdb, 0x7f,
	0xcc, 0x43, 0x03, 0xb7, 0x1b, 0x2e, 0xd9, 0xb7, 0x50, 0xa1, 0x28, 0x68, 0xe5, 0x93, 0xd9, 0x96,
	0x82, 0x45, 0x23, 0x9d, 0x6d, 0x11, 0xc5, 0x7a, 0x1e, 0xdb, 0xbb, 0x2e, 0x9f, 0xee, 0xa7, 0xf3,
	0xa9, 0x91, 0xde, 0xf4, 0x89, 0x6c, 0xfa, 0x7d, 0x1e, 0x1a, 0x32, 0xbd, 0x5f, 0xba, 0x5c, 0x68,
	0xe7, 0x3e, 0x87, 0xa2, 0xeb, 0x9d, 0xf9, 0xe8, 0xd8, 0xdd, 0x78, 0x8b, 0x46, 0x90, 0x4e, 0xcf,
	0x3b, 0xf3, 0xb5, 0x53, 0x0a, 0x6a, 0xf5, 0xa1, 0x1a, 0x89, 0x32, 0x9c, 0xf9, 0x2c, 0xed, 0xcc,
	0xed, 0xc4, 0xae, 0x8f, 0xf3, 0x38, 0xe9, 0xd4, 0xdf, 0xf2, 0x50, 0xef, 0xb2, 0x4b, 0x57, 0xd6,
	0x25, 0xe5, 0xd3, 0x07, 0x50, 0xd8, 0x1f, 0x9c, 0x62, 0x65, 0xa9, 0x62, 0x71, 0x1c, 0x9c, 0x3a,
	0x52, 0x4a, 0xee, 0x42, 0xf1, 0x68, 0x70, 0xca, 0x71, 0xdf, 0xa2, 0xf6, 0x68, 0x70, 0xea, 0x28,
	0xb1, 0xe4, 0x3a, 0xbb, 0xc7, 0x58, 0xfd, 0x50, 0xeb, 0xec, 0x1e, 0x3b, 0x52, 0x4a, 0xfe, 0x1f,
	0xca, 0xb8, 0x4f, 0xd3, 0xe5, 0xce, 0x94, 0x1d, 0xa3, 0x95, 0x40, 0x2e, 0xfc, 0x90, 0x4e, 0x98,
	0xca, 0xfd, 0x08, 0x38, 0xd4, 0x42, 0xc7, 0x68, 0xed, 0x5d, 0x58, 0x1f, 0xcc, 0xa7, 0xd3, 0x64,
	0x69, 0xdc, 0xc2, 0xd2, 0x68, 0xea, 0x0d, 0x8e, 0xa2, 0x62, 0x36, 0xc6, 0x0d, 0x8a, 0x23, 0xfb,
	0xcf, 0x05, 0x68, 0x74, 0x25, 0xc4, 0x3b, 0xf3, 0xf5, 0xff, 0xdf, 0x83, 0xa2, 0xe4, 0x60, 0x00,
	0x40, 0x4f, 0x2d, 0x21, 0x8e, 0x92, 0x93, 0x27, 0x50, 0x0e, 0xe7, 0x9e, 0xe7, 0x7a, 0x13, 0x8c,
	0xc2, 0x76, 0x0c, 0x89, 0xac, 0x74, 0x1c, 0x0d, 0xc1, 0xe2, 0x85, 0x04, 0xf2, 0x9d, 0x6c, 0x3f,
	0xb3, 0x60, 0xca, 0x04, 0x1b, 0xab, 0xda, 0x55, 0xdb, 0xb1, 0xb3, 0xd8, 0xfb, 0x06, 0xa4, 0xf9,
	0x31, 0x29, 0xdd, 0x65, 0x8a, 0xff, 0x6b, 0x97, 0xb9, 0x03, 0xd5, 0x60, 0xfe, 0x66, 0xea, 0x8e,
	0x7a, 0x03, 0xde, 0x5a, 0x55, 0x35, 0x33, 0x16, 0x58, 0x3f, 0x85, 0x7a, 0xd2, 0xdd, 0xf7, 0x90,
	0x55, 0xd6, 0x10, 0xd6, 0xd2, 0xff, 0xf0, 0x3e, 0x52, 0xf5, 0xdf, 0x05, 0x58, 0x5f, 0x50, 0x93,
	0x2f, 0xa1, 0xc4, 0x75, 0x8d, 0x93, 0x96, 0xd7, 0x76, 0xee, 0x64, 0x5a, 0xe9, 0xe0, 0x37, 0x62,
	0x65, 0x3c, 0xdc, 0x19, 0x9d, 0xb0, 0x3e, 0x9d, 0x31, 0xd3, 0xc2, 0x22, 0x01, 0xf9, 0x71, 0xdc,
	0x9f, 0x52, 0x6b, 0xb4, 0x68, 0x34, 0xbb, 0x41, 0xc5, 0x3d, 0xa2, 0x98, 0xea, 0x11, 0x3f, 0x80,
	0xd5, 0x39, 0x8f, 0x73, 0x7a, 0xd3, 0x1c, 0x24, 0xf4, 0x1a, 0x9d, 0x4a, 0x95, 0xa3, 0x11, 0xe4,
	0x10, 0x08, 0x9d, 0x4e, 0xfd, 0x11, 0x15, 0x6c, 0x1c, 0xad, 0xa7, 0xaa, 0xf4, 0xd7, 0xaf, 0x76,
	0x06, 0xc3, 0x1c, 0x2e, 0xca, 0xd7, 0x1d, 0x2e, 0xde, 0x6f, 0xb3, 0xfc, 0x19, 0x94, 0xb0, 0xad,
	0xd4, 0xa0, 0x7c, 0xda, 0x7f, 0xd1, 0x3f, 0x79, 0xdd, 0x6f, 0xe6, 0x48, 0x1d, 0x2a, 0xc3, 0xc1,
	0xc9, 0xc9, 0xcb, 0x5e, 0xff, 0xa8, 0x99, 0xd7, 0xa3, 0xdd, 0xd7, 0x7d, 0x39, 0x5a, 0x91, 0x40,
	0xe7, 0xb4, 0xaf, 0x06, 0x05, 0xa9, 0x3a, 0xec, 0xf5, 0x7b, 0xc3, 0x67, 0x07, 0xdd, 0x66, 0x91,
	0x00, 0x94, 0xf6, 0x9c, 0x93, 0x17, 0x07, 0xfd, 0xe6, 0xaa, 0xfd, 0x57, 0x3c, 0xc2, 0x0d, 0x7c,
	0x7f, 0x4a, 0xda, 0x50, 0xa0, 0x53, 0xb3, 0x3d, 0xaf, 0x8b, 0x86, 0x84, 0x90, 0x87, 0x50, 0x9c,
	0x73, 0x36, 0xc6, 0x6d, 0xda, 0x8a, 0xff, 0x5f, 0xda, 0xe9, 0x9c, 0x72, 0xb3, 0xbd, 0x14, 0xca,
	0x3a, 0x81, 0x6a, 0x24, 0xca, 0x08, 0xc4, 0xc3, 0x74, 0x20, 0xae, 0x9b, 0x38, 0x11, 0x8f, 0xdf,
	0x95, 0xa0, 0x86, 0xfa, 0x77, 0x74, 0xfc, 0x29, 0x54, 0xa4, 0x4b, 0xc3, 0xc0, 0x17, 0xe8, 0xfc,
	0x87, 0x29, 0x78, 0xe4, 0xbf, 0x44, 0x60, 0xc7, 0x32, 0x04, 0xf2, 0x15, 0x94, 0xe4, 0xf7, 0xe1,
	0x5b, 0x4c, 0xde, 0xbb, 0xd9, 0xd4, 0xc3, 0xb7, 0x9a, 0x88, 0x60, 0x72, 0x04, 0xf5, 0x91, 0x3f,
	0x9b, 0xb9, 0x02, 0xe7, 0x2d, 0x2a, 0xf2, 0xfd, 0x65, 0xf2, 0x7e, 0x02, 0xa5, 0x4d, 0xa4, 0x88,
	0x64, 0x17, 0xc0, 0x8c, 0x0f, 0xdf, 0xaa, 0x62, 0xb3, 0xd8, 0x72, 0x53, 0x66, 0x8c, 0x1f, 0x09,
	0x92, 0xf4, 0x85, 0xfd, 0x92, 0x8d, 0x04, 0x1b, 0xeb, 0xbe, 0x5d, 0xba, 0xce, 0x97, 0x83, 0x04,
	0x0a, 0x7d, 0x49, 0x12, 0x65, 0xf7, 0x4e, 0x85, 0xe9, 0x06, 0xdd, 0xdb, 0x7a, 0x06, 0xb5, 0x44,
	0xdc, 0x6e, 0x62, 0xa9, 0x0f, 0x1b, 0x4b, 0x41, 0xbc, 0x89, 0xbd, 0x97, 0xb0, 0xbe, 0x10, 0xcd,
	0x1b, 0x7a, 0xb7, 0x14, 0xd6, 0x9b, 0x9c, 0x7a, 0xfe, 0xb5, 0x02, 0x8d, 0xe1, 0xe8, 0x9c, 0x8d,
	0xe7, 0x53, 0x16, 0x76, 0xa9, 0xa0, 0xe4, 0x25, 0x34, 0x64, 0xf7, 0x7d, 0xe5, 0x23, 0x1a, 0x8f,
	0x3f, 0x9f, 0x62, 0x97, 0x4f, 0x62, 0x75, 0xb9, 0x32, 0x40, 0xbd, 0xc4, 0x69, 0x32, 0xe9, 0x41,
	0x9d, 0xc6, 0x29, 0xc1, 0x31, 0xeb, 0x3f, 0xc9, 0x32, 0x96, 0x48, 0x1d, 0x93, 0x2e, 0x49, 0x2a,
	0x79, 0xa4, 0x0e, 0xeb, 0x6a, 0x80, 0xbd, 0x75, 0x63, 0x29, 0xe7, 0x9c, 0x08, 0x62, 0x7d, 0x07,
	0x64, 0xd9, 0xbd, 0x8c, 0x50, 0xdd, 0x4a, 0x86, 0xaa, 0x9a, 0x8c, 0xf5, 0x09, 0x6c, 0x2c, 0xf9,
	0x94, 0x61, 0xe0, 0xe3, 0x74, 0xac, 0xd7, 0xd2, 0x95, 0x2c, 0x61, 0xf0, 0x79, 0xb1, 0xb2, 0xd2,
	0x2c, 0xd8, 0x7f, 0x2a, 0x40, 0x7d, 0x48, 0xa7, 0x8c, 0xcf, 0xa8, 0xa7, 0x22, 0xde, 0x87, 0x35,
	0xfc, 0xd1, 0xfd, 0xa3, 0xd0, 0x9f, 0x07, 0xe6, 0x00, 0x67, 0x42, 0x9e, 0xc0, 0x9a, 0x7f, 0x45,
	0xa0, 0x0e, 0xd3, 0x02, 0x9b, 0x7c, 0x01, 0xab, 0xf2, 0x2c, 0xc4, 0xd3, 0x25, 0x26, 0x65, 0x46,
	0x1e, 0x68, 0x90, 0xad, 0xb1, 0xe4, 0x6b, 0x28, 0xf9, 0xe1, 0x98, 0x85, 0x1c, 0x6b, 0xcb, 0xbd,
	0x0c, 0xd6, 0x89, 0x02, 0x60, 0x65, 0xd2, 0x68, 0x6b, 0x17, 0x36, 0x33, 0x7c, 0x7a, 0xa7, 0x38,
	0x77, 0x01, 0x62, 0x7f, 0x32, 0x98, 0xdb, 0xe9, 0x00, 0x27, 0x0f, 0x7d, 0x09, 0x2b, 0x87, 0x50,
	0x4b, 0xf8, 0x97, 0x61, 0xe6, 0xa3, 0xb4, 0x19, 0xbc, 0x9e, 0x28, 0x4e, 0xaa, 0x31, 0xe4, 0x61,
	0xbd, 0xcb, 0xde, 0xcc, 0x27, 0xb2, 0x5d, 0x32, 0x7d, 0x8e, 0xf9, 0x06, 0x1a, 0x3c, 0x99, 0xab,
	0xd8, 0x26, 0x36, 0x33, 0xd2, 0xd8, 0x49, 0x23, 0xc9, 0xd7, 0x50, 0xe7, 0x89, 0x18, 0xe2, 0xe4,
	0x64, 0x39, 0xba, 0x4e, 0x0a, 0x67, 0x7f, 0x03, 0x1b, 0x83, 0x79, 0x38, 0x61, 0x32, 0x8f, 0xf8,
	0x3b, 0x3d, 0x2d, 0xd8, 0x5b, 0x70, 0x4b, 0x3f, 0x1b, 0x1c, 0x33, 0x11, 0xba, 0x23, 0xc3, 0xb6,
	0xff, 0x90, 0x87, 0xdb, 0x0b, 0x0a, 0x1e, 0xf8, 0x1e, 0x67, 0x64, 0x0f, 0xca, 0x33, 0x2d, 0xc2,
	0xdd, 0xde, 0xd6, 0x86, 0x33, 0xd1, 0x1d, 0x1c, 0xe3, 0xc9, 0x0a, 0x89, 0xd6, 0x13, 0xa8, 0x27,
	0x15, 0xff, 0x2d, 0x03, 0xf2, 0x89, 0x98, 0xef, 0xfc, 0xb6, 0x04, 0x4d, 0x9c, 0x8b, 0x7a, 0x74,
	0xc2, 0x66, 0xcc, 0x13, 0xe4, 0x41, 0x7c, 0x62, 0xc1, 0x73, 0xcd, 0x2c, 0x10, 0x57, 0xd6, 0x46,
	0xf4, 0x1c, 0x61, 0x8e, 0x7a, 0x76, 0x8e, 0x3c, 0x84, 0x32, 0x5e, 0x93, 0xd2, 0x60, 0x62, 0x72,
	0x25, 0xbe, 0x42, 0xd9, 0x39, 0xf2, 0x18, 0x6a, 0x87, 0x21, 0x63, 0xef, 0xc0, 0xf8, 0x0c, 0x56,
	0xd5, 0x42, 0xa4, 0xb1, 0x9b, 0x19, 0x57, 0x42, 0x3b, 0x47, 0x3a, 0x50, 0x31, 0xb7, 0xd2, 0x4c,
	0x7c, 0xea, 0x6e, 0x6b, 0xe7, 0xc8, 0x03, 0x68, 0xec, 0x87, 0x8c, 0x0a, 0x66, 0x8a, 0x66, 0xba,
	0x5c, 0x5b, 0x15, 0x3d, 0xec, 0x75, 0xed, 0x1c, 0x69, 0x43, 0xc3, 0x61, 0x33, 0xff, 0x32, 0xc2,
	0x46, 0x4a, 0x2b, 0x39, 0x95, 0x72, 0xb9, 0xa1, 0x12, 0x28, 0xdb, 0x95, 0x05, 0xf0, 0xb7, 0x70,
	0x3b, 0x05, 0xee, 0x32, 0x41, 0xdd, 0x29, 0x1b, 0xa7, 0x49, 0x78, 0x09, 0x38, 0x08, 0x43, 0x3f,
	0xdc, 0xbb, 0x1a, 0x8a, 0xd0, 0xf5, 0x26, 0xca, 0xab, 0xaf, 0x60, 0xd3, 0x6c, 0x82, 0x63, 0xea,
	0x7a, 0x82, 0x79, 0xd4, 0x1b, 0x31, 0x82, 0xe7, 0xd1, 0x57, 0xe6, 0x49, 0x70, 0x71, 0xd6, 0xcf,
	0x61, 0xbd, 0xcf, 0x7e, 0x2d, 0x92, 0x94, 0xd4, 0x7c, 0x8b, 0x7c, 0x3b, 0x47, 0x76, 0x64, 0xad,
	0x30, 0x9b, 0x33, 0xd3, 0xbb, 0x85, 0xbd, 0xab, 0xa7, 0xd1, 0x31, 0x8b, 0x1e, 0x2c, 0x8c, 0x67,
	0xfd, 0xf9, 0x8c, 0x85, 0xee, 0x68, 0x39, 0x78, 0x8f, 0xe4, 0xdd, 0x35, 0x9c, 0xc4, 0x8c, 0xef,
	0x0f, 0x5f, 0x17, 0xca, 0x98, 0xfb, 0xc4, 0xca, 0xdc, 0x39, 0x6a, 0x03, 0x5a, 0x1f, 0x7c, 0xcf,
	0xae, 0xb2, 0x73, 0x3b, 0xff, 0x2c, 0x40, 0x49, 0xeb, 0x64, 0xaf, 0x1b, 0xcc, 0xf9, 0xb9, 0xcc,
	0x2c, 0x33, 0xf1, 0xfe, 0xf9, 0xdc, 0xbb, 0xb0, 0xb0, 0xbb, 0x0c, 0x42, 0x7f, 0x12, 0x32, 0xce,
	0xed, 0x5c, 0x3b, 0xff, 0x38, 0x4f, 0x76, 0x24, 0x5c, 0x5f, 0xb5, 0x09, 0x86, 0x61, 0xe1, 0xea,
	0x6d, 0x25, 0xad, 0xd8, 0xb9, 0xc7, 0x79, 0xf2, 0x14, 0xaa, 0xd1, 0x93, 0x1e, 0xd9, 0x5a, 0x7a,
	0xe3, 0xd3, 0xac, 0x5b, 0x59, 0x6f, 0x7f, 0x76, 0x8e, 0xdc, 0x87, 0xca, 0x50, 0xf8, 0x81, 0xe2,
	0x5e, 0x9b, 0x81, 0x3f, 0x01, 0x88, 0x4b, 0x18, 0xf9, 0x3f, 0xe3, 0xd7, 0x42, 0x51, 0xbb, 0x3e,
	0xab, 0x7e, 0x08, 0x10, 0x5f, 0xea, 0x12, 0xd3, 0x64, 0xdf, 0x45, 0xed, 0x1c, 0xd9, 0x83, 0x5a,
	0xe2, 0xa5, 0x94, 0xdc, 0x4b, 0x86, 0x7b, 0xf9, 0x09, 0xd5, 0x54, 0x12, 0x94, 0x0e, 0x03, 0x36,
	0xb2, 0x73, 0xe4, 0x89, 0xbe, 0xcc, 0xbc, 0xf4, 0x27, 0x9c, 0x24, 0x26, 0x92, 0x63, 0xc3, 0xdb,
	0x4c, 0x8b, 0xe3, 0x90, 0x76, 0xa0, 0x76, 0xc4, 0x84, 0x79, 0x2c, 0x48, 0x78, 0xbc, 0x99, 0xf1,
	0x8c, 0x60, 0xe7, 0xde, 0x94, 0xd4, 0x13, 0xf9, 0x17, 0xff, 0x09, 0x00, 0x00, 0xff, 0xff, 0x30,
	0x38, 0x75, 0xb3, 0xc8, 0x17, 0x00, 0x00,
}
