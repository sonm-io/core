// Code generated by protoc-gen-go. DO NOT EDIT.
// source: rendezvous.proto

package sonm

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// grpccmd imports
import (
	"io"

	"github.com/spf13/cobra"
	"github.com/sshaman1101/grpccmd"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// ConnectRequest describres a connection request to a remote target, possibly
// located under the NAT.
type ConnectRequest struct {
	// ID describes an unique ID of a target. Mainly it's an ETH address.
	ID string `protobuf:"bytes,1,opt,name=ID" json:"ID,omitempty"`
	// Protocol describes network protocol the peer wants to resolve.
	Protocol string `protobuf:"bytes,2,opt,name=protocol" json:"protocol,omitempty"`
	// PrivateAddrs describes source private addresses.
	PrivateAddrs []*Addr `protobuf:"bytes,3,rep,name=privateAddrs" json:"privateAddrs,omitempty"`
}

func (m *ConnectRequest) Reset()                    { *m = ConnectRequest{} }
func (m *ConnectRequest) String() string            { return proto.CompactTextString(m) }
func (*ConnectRequest) ProtoMessage()               {}
func (*ConnectRequest) Descriptor() ([]byte, []int) { return fileDescriptor14, []int{0} }

func (m *ConnectRequest) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *ConnectRequest) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *ConnectRequest) GetPrivateAddrs() []*Addr {
	if m != nil {
		return m.PrivateAddrs
	}
	return nil
}

type PublishRequest struct {
	// Protocol describes network protocol the peer wants to publish.
	Protocol string `protobuf:"bytes,1,opt,name=protocol" json:"protocol,omitempty"`
	// PrivateAddrs describes source private addresses.
	PrivateAddrs []*Addr `protobuf:"bytes,2,rep,name=privateAddrs" json:"privateAddrs,omitempty"`
}

func (m *PublishRequest) Reset()                    { *m = PublishRequest{} }
func (m *PublishRequest) String() string            { return proto.CompactTextString(m) }
func (*PublishRequest) ProtoMessage()               {}
func (*PublishRequest) Descriptor() ([]byte, []int) { return fileDescriptor14, []int{1} }

func (m *PublishRequest) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *PublishRequest) GetPrivateAddrs() []*Addr {
	if m != nil {
		return m.PrivateAddrs
	}
	return nil
}

// RendezvousReply describes a rendezvous point reply.
type RendezvousReply struct {
	// PublicAddr is a public network address of a target.
	PublicAddr *Addr `protobuf:"bytes,1,opt,name=publicAddr" json:"publicAddr,omitempty"`
	// PrivateAddrs describes private network addresses of a target.
	//
	// These addresses should be used to perform an initial connection
	// attempt for cases where both peers are located under the same NAT.
	PrivateAddrs []*Addr `protobuf:"bytes,2,rep,name=privateAddrs" json:"privateAddrs,omitempty"`
}

func (m *RendezvousReply) Reset()                    { *m = RendezvousReply{} }
func (m *RendezvousReply) String() string            { return proto.CompactTextString(m) }
func (*RendezvousReply) ProtoMessage()               {}
func (*RendezvousReply) Descriptor() ([]byte, []int) { return fileDescriptor14, []int{2} }

func (m *RendezvousReply) GetPublicAddr() *Addr {
	if m != nil {
		return m.PublicAddr
	}
	return nil
}

func (m *RendezvousReply) GetPrivateAddrs() []*Addr {
	if m != nil {
		return m.PrivateAddrs
	}
	return nil
}

// RendezvousState is a response returned from Info handle.
type RendezvousState struct {
	State map[string]*RendezvousMeeting `protobuf:"bytes,1,rep,name=state" json:"state,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *RendezvousState) Reset()                    { *m = RendezvousState{} }
func (m *RendezvousState) String() string            { return proto.CompactTextString(m) }
func (*RendezvousState) ProtoMessage()               {}
func (*RendezvousState) Descriptor() ([]byte, []int) { return fileDescriptor14, []int{3} }

func (m *RendezvousState) GetState() map[string]*RendezvousMeeting {
	if m != nil {
		return m.State
	}
	return nil
}

// RendezvousMeeting represents rendezvous point.
type RendezvousMeeting struct {
	Clients map[string]*RendezvousReply `protobuf:"bytes,1,rep,name=clients" json:"clients,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Servers map[string]*RendezvousReply `protobuf:"bytes,2,rep,name=servers" json:"servers,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *RendezvousMeeting) Reset()                    { *m = RendezvousMeeting{} }
func (m *RendezvousMeeting) String() string            { return proto.CompactTextString(m) }
func (*RendezvousMeeting) ProtoMessage()               {}
func (*RendezvousMeeting) Descriptor() ([]byte, []int) { return fileDescriptor14, []int{4} }

func (m *RendezvousMeeting) GetClients() map[string]*RendezvousReply {
	if m != nil {
		return m.Clients
	}
	return nil
}

func (m *RendezvousMeeting) GetServers() map[string]*RendezvousReply {
	if m != nil {
		return m.Servers
	}
	return nil
}

type ResolveMetaReply struct {
	IDs []string `protobuf:"bytes,1,rep,name=IDs" json:"IDs,omitempty"`
}

func (m *ResolveMetaReply) Reset()                    { *m = ResolveMetaReply{} }
func (m *ResolveMetaReply) String() string            { return proto.CompactTextString(m) }
func (*ResolveMetaReply) ProtoMessage()               {}
func (*ResolveMetaReply) Descriptor() ([]byte, []int) { return fileDescriptor14, []int{5} }

func (m *ResolveMetaReply) GetIDs() []string {
	if m != nil {
		return m.IDs
	}
	return nil
}

func init() {
	proto.RegisterType((*ConnectRequest)(nil), "sonm.ConnectRequest")
	proto.RegisterType((*PublishRequest)(nil), "sonm.PublishRequest")
	proto.RegisterType((*RendezvousReply)(nil), "sonm.RendezvousReply")
	proto.RegisterType((*RendezvousState)(nil), "sonm.RendezvousState")
	proto.RegisterType((*RendezvousMeeting)(nil), "sonm.RendezvousMeeting")
	proto.RegisterType((*ResolveMetaReply)(nil), "sonm.ResolveMetaReply")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Rendezvous service

type RendezvousClient interface {
	// Resolve resolves the remote peer addresses.
	Resolve(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*RendezvousReply, error)
	// ResolveAll resolves remote servers using the specified peer ID,
	// returning the list of unique id's of these servets.
	//
	// Such UUIDs can be used for establishing aimed connection with all
	// servers under the same ID without randomization games.
	ResolveAll(ctx context.Context, in *ID, opts ...grpc.CallOption) (*ResolveMetaReply, error)
	// Publish allows to publish the caller server's endpoints.
	//
	// While published the server can be located using the ID extracted from
	// the transport credentials.
	Publish(ctx context.Context, in *PublishRequest, opts ...grpc.CallOption) (*RendezvousReply, error)
	// Info returns server's internal state.
	Info(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*RendezvousState, error)
}

type rendezvousClient struct {
	cc *grpc.ClientConn
}

func NewRendezvousClient(cc *grpc.ClientConn) RendezvousClient {
	return &rendezvousClient{cc}
}

func (c *rendezvousClient) Resolve(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*RendezvousReply, error) {
	out := new(RendezvousReply)
	err := grpc.Invoke(ctx, "/sonm.Rendezvous/Resolve", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rendezvousClient) ResolveAll(ctx context.Context, in *ID, opts ...grpc.CallOption) (*ResolveMetaReply, error) {
	out := new(ResolveMetaReply)
	err := grpc.Invoke(ctx, "/sonm.Rendezvous/ResolveAll", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rendezvousClient) Publish(ctx context.Context, in *PublishRequest, opts ...grpc.CallOption) (*RendezvousReply, error) {
	out := new(RendezvousReply)
	err := grpc.Invoke(ctx, "/sonm.Rendezvous/Publish", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rendezvousClient) Info(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*RendezvousState, error) {
	out := new(RendezvousState)
	err := grpc.Invoke(ctx, "/sonm.Rendezvous/Info", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Rendezvous service

type RendezvousServer interface {
	// Resolve resolves the remote peer addresses.
	Resolve(context.Context, *ConnectRequest) (*RendezvousReply, error)
	// ResolveAll resolves remote servers using the specified peer ID,
	// returning the list of unique id's of these servets.
	//
	// Such UUIDs can be used for establishing aimed connection with all
	// servers under the same ID without randomization games.
	ResolveAll(context.Context, *ID) (*ResolveMetaReply, error)
	// Publish allows to publish the caller server's endpoints.
	//
	// While published the server can be located using the ID extracted from
	// the transport credentials.
	Publish(context.Context, *PublishRequest) (*RendezvousReply, error)
	// Info returns server's internal state.
	Info(context.Context, *Empty) (*RendezvousState, error)
}

func RegisterRendezvousServer(s *grpc.Server, srv RendezvousServer) {
	s.RegisterService(&_Rendezvous_serviceDesc, srv)
}

func _Rendezvous_Resolve_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RendezvousServer).Resolve(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.Rendezvous/Resolve",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RendezvousServer).Resolve(ctx, req.(*ConnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rendezvous_ResolveAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RendezvousServer).ResolveAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.Rendezvous/ResolveAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RendezvousServer).ResolveAll(ctx, req.(*ID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rendezvous_Publish_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublishRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RendezvousServer).Publish(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.Rendezvous/Publish",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RendezvousServer).Publish(ctx, req.(*PublishRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rendezvous_Info_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RendezvousServer).Info(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.Rendezvous/Info",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RendezvousServer).Info(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _Rendezvous_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sonm.Rendezvous",
	HandlerType: (*RendezvousServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Resolve",
			Handler:    _Rendezvous_Resolve_Handler,
		},
		{
			MethodName: "ResolveAll",
			Handler:    _Rendezvous_ResolveAll_Handler,
		},
		{
			MethodName: "Publish",
			Handler:    _Rendezvous_Publish_Handler,
		},
		{
			MethodName: "Info",
			Handler:    _Rendezvous_Info_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rendezvous.proto",
}

// Begin grpccmd
var _ = grpccmd.RunE

// Rendezvous
var _RendezvousCmd = &cobra.Command{
	Use:   "rendezvous [method]",
	Short: "Subcommand for the Rendezvous service.",
}

var _Rendezvous_ResolveCmd = &cobra.Command{
	Use:   "resolve",
	Short: "Make the Resolve method call, input-type: sonm.ConnectRequest output-type: sonm.RendezvousReply",
	RunE: grpccmd.RunE(
		"Resolve",
		"sonm.ConnectRequest",
		func(c io.Closer) interface{} {
			cc := c.(*grpc.ClientConn)
			return NewRendezvousClient(cc)
		},
	),
}

var _Rendezvous_ResolveCmd_gen = &cobra.Command{
	Use:   "resolve-gen",
	Short: "Generate JSON for method call of Resolve (input-type: sonm.ConnectRequest)",
	RunE:  grpccmd.TypeToJson("sonm.ConnectRequest"),
}

var _Rendezvous_ResolveAllCmd = &cobra.Command{
	Use:   "resolveAll",
	Short: "Make the ResolveAll method call, input-type: sonm.ID output-type: sonm.ResolveMetaReply",
	RunE: grpccmd.RunE(
		"ResolveAll",
		"sonm.ID",
		func(c io.Closer) interface{} {
			cc := c.(*grpc.ClientConn)
			return NewRendezvousClient(cc)
		},
	),
}

var _Rendezvous_ResolveAllCmd_gen = &cobra.Command{
	Use:   "resolveAll-gen",
	Short: "Generate JSON for method call of ResolveAll (input-type: sonm.ID)",
	RunE:  grpccmd.TypeToJson("sonm.ID"),
}

var _Rendezvous_PublishCmd = &cobra.Command{
	Use:   "publish",
	Short: "Make the Publish method call, input-type: sonm.PublishRequest output-type: sonm.RendezvousReply",
	RunE: grpccmd.RunE(
		"Publish",
		"sonm.PublishRequest",
		func(c io.Closer) interface{} {
			cc := c.(*grpc.ClientConn)
			return NewRendezvousClient(cc)
		},
	),
}

var _Rendezvous_PublishCmd_gen = &cobra.Command{
	Use:   "publish-gen",
	Short: "Generate JSON for method call of Publish (input-type: sonm.PublishRequest)",
	RunE:  grpccmd.TypeToJson("sonm.PublishRequest"),
}

var _Rendezvous_InfoCmd = &cobra.Command{
	Use:   "info",
	Short: "Make the Info method call, input-type: sonm.Empty output-type: sonm.RendezvousState",
	RunE: grpccmd.RunE(
		"Info",
		"sonm.Empty",
		func(c io.Closer) interface{} {
			cc := c.(*grpc.ClientConn)
			return NewRendezvousClient(cc)
		},
	),
}

var _Rendezvous_InfoCmd_gen = &cobra.Command{
	Use:   "info-gen",
	Short: "Generate JSON for method call of Info (input-type: sonm.Empty)",
	RunE:  grpccmd.TypeToJson("sonm.Empty"),
}

// Register commands with the root command and service command
func init() {
	grpccmd.RegisterServiceCmd(_RendezvousCmd)
	_RendezvousCmd.AddCommand(
		_Rendezvous_ResolveCmd,
		_Rendezvous_ResolveCmd_gen,
		_Rendezvous_ResolveAllCmd,
		_Rendezvous_ResolveAllCmd_gen,
		_Rendezvous_PublishCmd,
		_Rendezvous_PublishCmd_gen,
		_Rendezvous_InfoCmd,
		_Rendezvous_InfoCmd_gen,
	)
}

// End grpccmd

func init() { proto.RegisterFile("rendezvous.proto", fileDescriptor14) }

var fileDescriptor14 = []byte{
	// 453 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x53, 0xcd, 0x6a, 0xdb, 0x40,
	0x10, 0xb6, 0xe4, 0xa4, 0x89, 0xc7, 0xc1, 0x51, 0x97, 0xfe, 0x08, 0x9d, 0x8c, 0xc8, 0x21, 0xf4,
	0x47, 0x14, 0x17, 0x4a, 0xe8, 0xa1, 0x10, 0xa2, 0x1c, 0x74, 0x08, 0x34, 0x9b, 0x6b, 0x2f, 0x8a,
	0x3c, 0x6d, 0x45, 0xd7, 0xbb, 0xaa, 0x76, 0x25, 0x50, 0x9f, 0xa5, 0x2f, 0xd2, 0xb7, 0xe9, 0xa3,
	0x94, 0xdd, 0x95, 0x1c, 0xc9, 0x89, 0x31, 0x85, 0x5c, 0xec, 0xd1, 0xec, 0xf7, 0x33, 0x33, 0xbb,
	0x03, 0x5e, 0x89, 0x7c, 0x89, 0xbf, 0x6a, 0x51, 0xc9, 0xa8, 0x28, 0x85, 0x12, 0x64, 0x4f, 0x0a,
	0xbe, 0x0a, 0x8e, 0x73, 0xae, 0xff, 0x79, 0x9e, 0xda, 0x74, 0x30, 0xe1, 0xa8, 0x6c, 0x18, 0x32,
	0x98, 0x5d, 0x08, 0xce, 0x31, 0x53, 0x14, 0x7f, 0x56, 0x28, 0x15, 0x99, 0x81, 0x9b, 0xc4, 0xbe,
	0x33, 0x77, 0x4e, 0x27, 0xd4, 0x4d, 0x62, 0x12, 0xc0, 0xa1, 0x81, 0x66, 0x82, 0xf9, 0xae, 0xc9,
	0xae, 0xbf, 0x49, 0x04, 0x47, 0x45, 0x99, 0xd7, 0xa9, 0xc2, 0xf3, 0xe5, 0xb2, 0x94, 0xfe, 0x78,
	0x3e, 0x3e, 0x9d, 0x2e, 0x20, 0xd2, 0x76, 0x91, 0x4e, 0xd1, 0xc1, 0x79, 0xf8, 0x05, 0x66, 0x9f,
	0xab, 0x5b, 0x96, 0xcb, 0xef, 0x9d, 0x5b, 0x5f, 0xdd, 0xd9, 0xa1, 0xee, 0xee, 0x50, 0x5f, 0xc1,
	0x31, 0x5d, 0x4f, 0x80, 0x62, 0xc1, 0x1a, 0xf2, 0x0a, 0xa0, 0xd0, 0x86, 0x99, 0x46, 0x18, 0x83,
	0xa1, 0x40, 0xef, 0xf4, 0xbf, 0xed, 0x7e, 0x3b, 0x7d, 0xbf, 0x1b, 0x95, 0x2a, 0x24, 0x1f, 0x60,
	0x5f, 0xea, 0xc0, 0x77, 0x0c, 0x79, 0x6e, 0xc9, 0x1b, 0xa8, 0xc8, 0xfc, 0x5e, 0x72, 0x55, 0x36,
	0xd4, 0xc2, 0x83, 0x6b, 0x80, 0xbb, 0x24, 0xf1, 0x60, 0xfc, 0x03, 0x9b, 0x76, 0x1e, 0x3a, 0x24,
	0x6f, 0x61, 0xbf, 0x4e, 0x59, 0x85, 0xe6, 0x06, 0xa6, 0x8b, 0x97, 0x9b, 0xba, 0x57, 0x88, 0x2a,
	0xe7, 0xdf, 0xa8, 0x45, 0x7d, 0x74, 0xcf, 0x9c, 0xf0, 0x8f, 0x0b, 0x4f, 0xef, 0x01, 0xc8, 0x27,
	0x38, 0xc8, 0x58, 0x8e, 0x5c, 0xc9, 0xb6, 0xc4, 0x93, 0x2d, 0x52, 0xd1, 0x85, 0x85, 0xd9, 0x32,
	0x3b, 0x92, 0xe6, 0x4b, 0x2c, 0x6b, 0x5c, 0xcf, 0x67, 0x2b, 0xff, 0xc6, 0xc2, 0x5a, 0x7e, 0x4b,
	0x0a, 0xae, 0xe1, 0xa8, 0x2f, 0xfc, 0x40, 0xab, 0xaf, 0x87, 0xad, 0x3e, 0xdf, 0xd4, 0x37, 0x17,
	0xdb, 0x6b, 0x54, 0x4b, 0xf6, 0xbd, 0x1e, 0x41, 0x32, 0x3c, 0x01, 0x8f, 0xa2, 0x14, 0xac, 0xc6,
	0x2b, 0x54, 0xa9, 0x7d, 0x4a, 0x1e, 0x8c, 0x93, 0xd8, 0x4e, 0x6d, 0x42, 0x75, 0xb8, 0xf8, 0xeb,
	0x00, 0xdc, 0x89, 0x90, 0x33, 0x38, 0x68, 0x49, 0xe4, 0x99, 0x75, 0x18, 0x6e, 0x56, 0xf0, 0xb0,
	0x6f, 0x38, 0x22, 0xef, 0xb4, 0x8e, 0x61, 0x9e, 0x33, 0x46, 0x0e, 0x2d, 0x2c, 0x89, 0x83, 0x17,
	0x1d, 0x61, 0x58, 0x4a, 0x38, 0xd2, 0x5e, 0xed, 0x22, 0x75, 0x5e, 0xc3, 0xbd, 0xda, 0xee, 0xf5,
	0x06, 0xf6, 0x12, 0xfe, 0x55, 0x90, 0xa9, 0x05, 0x5c, 0xae, 0x0a, 0xd5, 0xdc, 0x47, 0x9b, 0xc7,
	0x18, 0x8e, 0x6e, 0x9f, 0x98, 0x65, 0x7c, 0xff, 0x2f, 0x00, 0x00, 0xff, 0xff, 0xca, 0x64, 0x7d,
	0x43, 0x5b, 0x04, 0x00, 0x00,
}
