// Code generated by protoc-gen-go. DO NOT EDIT.
// source: hub.proto

package sonm

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// grpccmd imports
import (
	"io"

	"github.com/spf13/cobra"
	"github.com/sshaman1101/grpccmd"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type TaskStatusReply_Status int32

const (
	TaskStatusReply_UNKNOWN  TaskStatusReply_Status = 0
	TaskStatusReply_SPOOLING TaskStatusReply_Status = 1
	TaskStatusReply_SPAWNING TaskStatusReply_Status = 2
	TaskStatusReply_RUNNING  TaskStatusReply_Status = 3
	TaskStatusReply_FINISHED TaskStatusReply_Status = 4
	TaskStatusReply_BROKEN   TaskStatusReply_Status = 5
)

var TaskStatusReply_Status_name = map[int32]string{
	0: "UNKNOWN",
	1: "SPOOLING",
	2: "SPAWNING",
	3: "RUNNING",
	4: "FINISHED",
	5: "BROKEN",
}
var TaskStatusReply_Status_value = map[string]int32{
	"UNKNOWN":  0,
	"SPOOLING": 1,
	"SPAWNING": 2,
	"RUNNING":  3,
	"FINISHED": 4,
	"BROKEN":   5,
}

func (x TaskStatusReply_Status) String() string {
	return proto.EnumName(TaskStatusReply_Status_name, int32(x))
}
func (TaskStatusReply_Status) EnumDescriptor() ([]byte, []int) { return fileDescriptor7, []int{9, 0} }

type StartTaskRequest struct {
	// Deal points to the deal associated with workers where the task should be
	// started.
	Deal *Deal `protobuf:"bytes,1,opt,name=deal" json:"deal,omitempty"`
	// Container describes container settings.
	Container *Container        `protobuf:"bytes,2,opt,name=container" json:"container,omitempty"`
	Resources *AskPlanResources `protobuf:"bytes,3,opt,name=resources" json:"resources,omitempty"`
}

func (m *StartTaskRequest) Reset()                    { *m = StartTaskRequest{} }
func (m *StartTaskRequest) String() string            { return proto.CompactTextString(m) }
func (*StartTaskRequest) ProtoMessage()               {}
func (*StartTaskRequest) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{0} }

func (m *StartTaskRequest) GetDeal() *Deal {
	if m != nil {
		return m.Deal
	}
	return nil
}

func (m *StartTaskRequest) GetContainer() *Container {
	if m != nil {
		return m.Container
	}
	return nil
}

func (m *StartTaskRequest) GetResources() *AskPlanResources {
	if m != nil {
		return m.Resources
	}
	return nil
}

type HubJoinNetworkRequest struct {
	TaskID    string `protobuf:"bytes,1,opt,name=taskID" json:"taskID,omitempty"`
	NetworkID string `protobuf:"bytes,2,opt,name=networkID" json:"networkID,omitempty"`
}

func (m *HubJoinNetworkRequest) Reset()                    { *m = HubJoinNetworkRequest{} }
func (m *HubJoinNetworkRequest) String() string            { return proto.CompactTextString(m) }
func (*HubJoinNetworkRequest) ProtoMessage()               {}
func (*HubJoinNetworkRequest) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{1} }

func (m *HubJoinNetworkRequest) GetTaskID() string {
	if m != nil {
		return m.TaskID
	}
	return ""
}

func (m *HubJoinNetworkRequest) GetNetworkID() string {
	if m != nil {
		return m.NetworkID
	}
	return ""
}

type StartTaskReply struct {
	Id         string   `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Endpoint   []string `protobuf:"bytes,2,rep,name=endpoint" json:"endpoint,omitempty"`
	HubAddr    string   `protobuf:"bytes,3,opt,name=hubAddr" json:"hubAddr,omitempty"`
	NetworkIDs []string `protobuf:"bytes,4,rep,name=networkIDs" json:"networkIDs,omitempty"`
}

func (m *StartTaskReply) Reset()                    { *m = StartTaskReply{} }
func (m *StartTaskReply) String() string            { return proto.CompactTextString(m) }
func (*StartTaskReply) ProtoMessage()               {}
func (*StartTaskReply) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{2} }

func (m *StartTaskReply) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *StartTaskReply) GetEndpoint() []string {
	if m != nil {
		return m.Endpoint
	}
	return nil
}

func (m *StartTaskReply) GetHubAddr() string {
	if m != nil {
		return m.HubAddr
	}
	return ""
}

func (m *StartTaskReply) GetNetworkIDs() []string {
	if m != nil {
		return m.NetworkIDs
	}
	return nil
}

type HubStatusReply struct {
	Uptime           uint64 `protobuf:"varint,1,opt,name=uptime" json:"uptime,omitempty"`
	Version          string `protobuf:"bytes,2,opt,name=version" json:"version,omitempty"`
	Platform         string `protobuf:"bytes,3,opt,name=platform" json:"platform,omitempty"`
	EthAddr          string `protobuf:"bytes,4,opt,name=ethAddr" json:"ethAddr,omitempty"`
	TaskCount        uint32 `protobuf:"varint,5,opt,name=taskCount" json:"taskCount,omitempty"`
	DWHStatus        string `protobuf:"bytes,6,opt,name=DWHStatus" json:"DWHStatus,omitempty"`
	RendezvousStatus string `protobuf:"bytes,7,opt,name=rendezvousStatus" json:"rendezvousStatus,omitempty"`
}

func (m *HubStatusReply) Reset()                    { *m = HubStatusReply{} }
func (m *HubStatusReply) String() string            { return proto.CompactTextString(m) }
func (*HubStatusReply) ProtoMessage()               {}
func (*HubStatusReply) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{3} }

func (m *HubStatusReply) GetUptime() uint64 {
	if m != nil {
		return m.Uptime
	}
	return 0
}

func (m *HubStatusReply) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *HubStatusReply) GetPlatform() string {
	if m != nil {
		return m.Platform
	}
	return ""
}

func (m *HubStatusReply) GetEthAddr() string {
	if m != nil {
		return m.EthAddr
	}
	return ""
}

func (m *HubStatusReply) GetTaskCount() uint32 {
	if m != nil {
		return m.TaskCount
	}
	return 0
}

func (m *HubStatusReply) GetDWHStatus() string {
	if m != nil {
		return m.DWHStatus
	}
	return ""
}

func (m *HubStatusReply) GetRendezvousStatus() string {
	if m != nil {
		return m.RendezvousStatus
	}
	return ""
}

type AskPlansReply struct {
	AskPlans map[string]*AskPlan `protobuf:"bytes,1,rep,name=askPlans" json:"askPlans,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *AskPlansReply) Reset()                    { *m = AskPlansReply{} }
func (m *AskPlansReply) String() string            { return proto.CompactTextString(m) }
func (*AskPlansReply) ProtoMessage()               {}
func (*AskPlansReply) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{4} }

func (m *AskPlansReply) GetAskPlans() map[string]*AskPlan {
	if m != nil {
		return m.AskPlans
	}
	return nil
}

type TaskListReply struct {
	Info map[string]*TaskStatusReply `protobuf:"bytes,1,rep,name=info" json:"info,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *TaskListReply) Reset()                    { *m = TaskListReply{} }
func (m *TaskListReply) String() string            { return proto.CompactTextString(m) }
func (*TaskListReply) ProtoMessage()               {}
func (*TaskListReply) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{5} }

func (m *TaskListReply) GetInfo() map[string]*TaskStatusReply {
	if m != nil {
		return m.Info
	}
	return nil
}

type DevicesReply struct {
	CPU     *CPU     `protobuf:"bytes,1,opt,name=CPU" json:"CPU,omitempty"`
	GPUs    []*GPU   `protobuf:"bytes,2,rep,name=GPUs" json:"GPUs,omitempty"`
	RAM     *RAM     `protobuf:"bytes,3,opt,name=RAM" json:"RAM,omitempty"`
	Network *Network `protobuf:"bytes,4,opt,name=network" json:"network,omitempty"`
	Storage *Storage `protobuf:"bytes,5,opt,name=storage" json:"storage,omitempty"`
}

func (m *DevicesReply) Reset()                    { *m = DevicesReply{} }
func (m *DevicesReply) String() string            { return proto.CompactTextString(m) }
func (*DevicesReply) ProtoMessage()               {}
func (*DevicesReply) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{6} }

func (m *DevicesReply) GetCPU() *CPU {
	if m != nil {
		return m.CPU
	}
	return nil
}

func (m *DevicesReply) GetGPUs() []*GPU {
	if m != nil {
		return m.GPUs
	}
	return nil
}

func (m *DevicesReply) GetRAM() *RAM {
	if m != nil {
		return m.RAM
	}
	return nil
}

func (m *DevicesReply) GetNetwork() *Network {
	if m != nil {
		return m.Network
	}
	return nil
}

func (m *DevicesReply) GetStorage() *Storage {
	if m != nil {
		return m.Storage
	}
	return nil
}

type PullTaskRequest struct {
	DealId string `protobuf:"bytes,1,opt,name=dealId" json:"dealId,omitempty"`
	TaskId string `protobuf:"bytes,2,opt,name=taskId" json:"taskId,omitempty"`
}

func (m *PullTaskRequest) Reset()                    { *m = PullTaskRequest{} }
func (m *PullTaskRequest) String() string            { return proto.CompactTextString(m) }
func (*PullTaskRequest) ProtoMessage()               {}
func (*PullTaskRequest) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{7} }

func (m *PullTaskRequest) GetDealId() string {
	if m != nil {
		return m.DealId
	}
	return ""
}

func (m *PullTaskRequest) GetTaskId() string {
	if m != nil {
		return m.TaskId
	}
	return ""
}

type DealInfoReply struct {
	Deal *Deal `protobuf:"bytes,1,opt,name=deal" json:"deal,omitempty"`
	// List of currently running tasks.
	Running *StatusMapReply `protobuf:"bytes,2,opt,name=running" json:"running,omitempty"`
	// List of completed tasks.
	Completed *StatusMapReply `protobuf:"bytes,3,opt,name=completed" json:"completed,omitempty"`
	// Resources is a real resources (cores, ram bytes, GPU devices, etc)
	// allocated on a worker for this deal.
	Resources *AskPlanResources `protobuf:"bytes,4,opt,name=resources" json:"resources,omitempty"`
}

func (m *DealInfoReply) Reset()                    { *m = DealInfoReply{} }
func (m *DealInfoReply) String() string            { return proto.CompactTextString(m) }
func (*DealInfoReply) ProtoMessage()               {}
func (*DealInfoReply) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{8} }

func (m *DealInfoReply) GetDeal() *Deal {
	if m != nil {
		return m.Deal
	}
	return nil
}

func (m *DealInfoReply) GetRunning() *StatusMapReply {
	if m != nil {
		return m.Running
	}
	return nil
}

func (m *DealInfoReply) GetCompleted() *StatusMapReply {
	if m != nil {
		return m.Completed
	}
	return nil
}

func (m *DealInfoReply) GetResources() *AskPlanResources {
	if m != nil {
		return m.Resources
	}
	return nil
}

type TaskStatusReply struct {
	Status             TaskStatusReply_Status `protobuf:"varint,1,opt,name=status,enum=sonm.TaskStatusReply_Status" json:"status,omitempty"`
	ImageName          string                 `protobuf:"bytes,2,opt,name=imageName" json:"imageName,omitempty"`
	Ports              string                 `protobuf:"bytes,3,opt,name=ports" json:"ports,omitempty"`
	Uptime             uint64                 `protobuf:"varint,4,opt,name=uptime" json:"uptime,omitempty"`
	Usage              *ResourceUsage         `protobuf:"bytes,5,opt,name=usage" json:"usage,omitempty"`
	AllocatedResources *AskPlanResources      `protobuf:"bytes,6,opt,name=allocatedResources" json:"allocatedResources,omitempty"`
	// Deprecated: TODO: minerID is meaningless
	MinerID string `protobuf:"bytes,7,opt,name=minerID" json:"minerID,omitempty"`
}

func (m *TaskStatusReply) Reset()                    { *m = TaskStatusReply{} }
func (m *TaskStatusReply) String() string            { return proto.CompactTextString(m) }
func (*TaskStatusReply) ProtoMessage()               {}
func (*TaskStatusReply) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{9} }

func (m *TaskStatusReply) GetStatus() TaskStatusReply_Status {
	if m != nil {
		return m.Status
	}
	return TaskStatusReply_UNKNOWN
}

func (m *TaskStatusReply) GetImageName() string {
	if m != nil {
		return m.ImageName
	}
	return ""
}

func (m *TaskStatusReply) GetPorts() string {
	if m != nil {
		return m.Ports
	}
	return ""
}

func (m *TaskStatusReply) GetUptime() uint64 {
	if m != nil {
		return m.Uptime
	}
	return 0
}

func (m *TaskStatusReply) GetUsage() *ResourceUsage {
	if m != nil {
		return m.Usage
	}
	return nil
}

func (m *TaskStatusReply) GetAllocatedResources() *AskPlanResources {
	if m != nil {
		return m.AllocatedResources
	}
	return nil
}

func (m *TaskStatusReply) GetMinerID() string {
	if m != nil {
		return m.MinerID
	}
	return ""
}

type StatusMapReply struct {
	Statuses map[string]*TaskStatusReply `protobuf:"bytes,1,rep,name=statuses" json:"statuses,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *StatusMapReply) Reset()                    { *m = StatusMapReply{} }
func (m *StatusMapReply) String() string            { return proto.CompactTextString(m) }
func (*StatusMapReply) ProtoMessage()               {}
func (*StatusMapReply) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{10} }

func (m *StatusMapReply) GetStatuses() map[string]*TaskStatusReply {
	if m != nil {
		return m.Statuses
	}
	return nil
}

func init() {
	proto.RegisterType((*StartTaskRequest)(nil), "sonm.StartTaskRequest")
	proto.RegisterType((*HubJoinNetworkRequest)(nil), "sonm.HubJoinNetworkRequest")
	proto.RegisterType((*StartTaskReply)(nil), "sonm.StartTaskReply")
	proto.RegisterType((*HubStatusReply)(nil), "sonm.HubStatusReply")
	proto.RegisterType((*AskPlansReply)(nil), "sonm.AskPlansReply")
	proto.RegisterType((*TaskListReply)(nil), "sonm.TaskListReply")
	proto.RegisterType((*DevicesReply)(nil), "sonm.DevicesReply")
	proto.RegisterType((*PullTaskRequest)(nil), "sonm.PullTaskRequest")
	proto.RegisterType((*DealInfoReply)(nil), "sonm.DealInfoReply")
	proto.RegisterType((*TaskStatusReply)(nil), "sonm.TaskStatusReply")
	proto.RegisterType((*StatusMapReply)(nil), "sonm.StatusMapReply")
	proto.RegisterEnum("sonm.TaskStatusReply_Status", TaskStatusReply_Status_name, TaskStatusReply_Status_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for WorkerManagement service

type WorkerManagementClient interface {
	// Status produse a detailed info about Hub
	Status(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*HubStatusReply, error)
	// Devices provides detailed information about device
	// and show benchmark results.
	Devices(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*DevicesReply, error)
	// FreeDevices provides information about unallocated resources
	// that can be turned into ask-plans.
	FreeDevices(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*DevicesReply, error)
	// Tasks produces a list of all running tasks on the Hub
	Tasks(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*TaskListReply, error)
	// AskPlans allows to obtain previously assigned Ask Plans from for a given worker.
	AskPlans(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*AskPlansReply, error)
	// CreateAskPlan allows to create rules
	// for creating Ask orders on Marketplace
	CreateAskPlan(ctx context.Context, in *AskPlan, opts ...grpc.CallOption) (*ID, error)
	// RemoveAskPlan allows to remove rules
	// for creating Ask orders on Marketplace
	RemoveAskPlan(ctx context.Context, in *ID, opts ...grpc.CallOption) (*Empty, error)
}

type workerManagementClient struct {
	cc *grpc.ClientConn
}

func NewWorkerManagementClient(cc *grpc.ClientConn) WorkerManagementClient {
	return &workerManagementClient{cc}
}

func (c *workerManagementClient) Status(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*HubStatusReply, error) {
	out := new(HubStatusReply)
	err := grpc.Invoke(ctx, "/sonm.WorkerManagement/Status", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerManagementClient) Devices(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*DevicesReply, error) {
	out := new(DevicesReply)
	err := grpc.Invoke(ctx, "/sonm.WorkerManagement/Devices", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerManagementClient) FreeDevices(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*DevicesReply, error) {
	out := new(DevicesReply)
	err := grpc.Invoke(ctx, "/sonm.WorkerManagement/FreeDevices", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerManagementClient) Tasks(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*TaskListReply, error) {
	out := new(TaskListReply)
	err := grpc.Invoke(ctx, "/sonm.WorkerManagement/Tasks", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerManagementClient) AskPlans(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*AskPlansReply, error) {
	out := new(AskPlansReply)
	err := grpc.Invoke(ctx, "/sonm.WorkerManagement/AskPlans", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerManagementClient) CreateAskPlan(ctx context.Context, in *AskPlan, opts ...grpc.CallOption) (*ID, error) {
	out := new(ID)
	err := grpc.Invoke(ctx, "/sonm.WorkerManagement/CreateAskPlan", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerManagementClient) RemoveAskPlan(ctx context.Context, in *ID, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/sonm.WorkerManagement/RemoveAskPlan", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for WorkerManagement service

type WorkerManagementServer interface {
	// Status produse a detailed info about Hub
	Status(context.Context, *Empty) (*HubStatusReply, error)
	// Devices provides detailed information about device
	// and show benchmark results.
	Devices(context.Context, *Empty) (*DevicesReply, error)
	// FreeDevices provides information about unallocated resources
	// that can be turned into ask-plans.
	FreeDevices(context.Context, *Empty) (*DevicesReply, error)
	// Tasks produces a list of all running tasks on the Hub
	Tasks(context.Context, *Empty) (*TaskListReply, error)
	// AskPlans allows to obtain previously assigned Ask Plans from for a given worker.
	AskPlans(context.Context, *Empty) (*AskPlansReply, error)
	// CreateAskPlan allows to create rules
	// for creating Ask orders on Marketplace
	CreateAskPlan(context.Context, *AskPlan) (*ID, error)
	// RemoveAskPlan allows to remove rules
	// for creating Ask orders on Marketplace
	RemoveAskPlan(context.Context, *ID) (*Empty, error)
}

func RegisterWorkerManagementServer(s *grpc.Server, srv WorkerManagementServer) {
	s.RegisterService(&_WorkerManagement_serviceDesc, srv)
}

func _WorkerManagement_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerManagementServer).Status(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.WorkerManagement/Status",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerManagementServer).Status(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerManagement_Devices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerManagementServer).Devices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.WorkerManagement/Devices",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerManagementServer).Devices(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerManagement_FreeDevices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerManagementServer).FreeDevices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.WorkerManagement/FreeDevices",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerManagementServer).FreeDevices(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerManagement_Tasks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerManagementServer).Tasks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.WorkerManagement/Tasks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerManagementServer).Tasks(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerManagement_AskPlans_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerManagementServer).AskPlans(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.WorkerManagement/AskPlans",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerManagementServer).AskPlans(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerManagement_CreateAskPlan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AskPlan)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerManagementServer).CreateAskPlan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.WorkerManagement/CreateAskPlan",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerManagementServer).CreateAskPlan(ctx, req.(*AskPlan))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerManagement_RemoveAskPlan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerManagementServer).RemoveAskPlan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.WorkerManagement/RemoveAskPlan",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerManagementServer).RemoveAskPlan(ctx, req.(*ID))
	}
	return interceptor(ctx, in, info, handler)
}

var _WorkerManagement_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sonm.WorkerManagement",
	HandlerType: (*WorkerManagementServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Status",
			Handler:    _WorkerManagement_Status_Handler,
		},
		{
			MethodName: "Devices",
			Handler:    _WorkerManagement_Devices_Handler,
		},
		{
			MethodName: "FreeDevices",
			Handler:    _WorkerManagement_FreeDevices_Handler,
		},
		{
			MethodName: "Tasks",
			Handler:    _WorkerManagement_Tasks_Handler,
		},
		{
			MethodName: "AskPlans",
			Handler:    _WorkerManagement_AskPlans_Handler,
		},
		{
			MethodName: "CreateAskPlan",
			Handler:    _WorkerManagement_CreateAskPlan_Handler,
		},
		{
			MethodName: "RemoveAskPlan",
			Handler:    _WorkerManagement_RemoveAskPlan_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "hub.proto",
}

// Client API for Hub service

type HubClient interface {
	PushTask(ctx context.Context, opts ...grpc.CallOption) (Hub_PushTaskClient, error)
	PullTask(ctx context.Context, in *PullTaskRequest, opts ...grpc.CallOption) (Hub_PullTaskClient, error)
	// StartTask schedules the task associcated with a deal on some miner.
	StartTask(ctx context.Context, in *StartTaskRequest, opts ...grpc.CallOption) (*StartTaskReply, error)
	StopTask(ctx context.Context, in *ID, opts ...grpc.CallOption) (*Empty, error)
	TaskStatus(ctx context.Context, in *ID, opts ...grpc.CallOption) (*TaskStatusReply, error)
	JoinNetwork(ctx context.Context, in *HubJoinNetworkRequest, opts ...grpc.CallOption) (*NetworkSpec, error)
	TaskLogs(ctx context.Context, in *TaskLogsRequest, opts ...grpc.CallOption) (Hub_TaskLogsClient, error)
	// Note: currently used for testing pusposes.
	GetDealInfo(ctx context.Context, in *ID, opts ...grpc.CallOption) (*DealInfoReply, error)
}

type hubClient struct {
	cc *grpc.ClientConn
}

func NewHubClient(cc *grpc.ClientConn) HubClient {
	return &hubClient{cc}
}

func (c *hubClient) PushTask(ctx context.Context, opts ...grpc.CallOption) (Hub_PushTaskClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Hub_serviceDesc.Streams[0], c.cc, "/sonm.Hub/PushTask", opts...)
	if err != nil {
		return nil, err
	}
	x := &hubPushTaskClient{stream}
	return x, nil
}

type Hub_PushTaskClient interface {
	Send(*Chunk) error
	Recv() (*Progress, error)
	grpc.ClientStream
}

type hubPushTaskClient struct {
	grpc.ClientStream
}

func (x *hubPushTaskClient) Send(m *Chunk) error {
	return x.ClientStream.SendMsg(m)
}

func (x *hubPushTaskClient) Recv() (*Progress, error) {
	m := new(Progress)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *hubClient) PullTask(ctx context.Context, in *PullTaskRequest, opts ...grpc.CallOption) (Hub_PullTaskClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Hub_serviceDesc.Streams[1], c.cc, "/sonm.Hub/PullTask", opts...)
	if err != nil {
		return nil, err
	}
	x := &hubPullTaskClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Hub_PullTaskClient interface {
	Recv() (*Chunk, error)
	grpc.ClientStream
}

type hubPullTaskClient struct {
	grpc.ClientStream
}

func (x *hubPullTaskClient) Recv() (*Chunk, error) {
	m := new(Chunk)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *hubClient) StartTask(ctx context.Context, in *StartTaskRequest, opts ...grpc.CallOption) (*StartTaskReply, error) {
	out := new(StartTaskReply)
	err := grpc.Invoke(ctx, "/sonm.Hub/StartTask", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hubClient) StopTask(ctx context.Context, in *ID, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/sonm.Hub/StopTask", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hubClient) TaskStatus(ctx context.Context, in *ID, opts ...grpc.CallOption) (*TaskStatusReply, error) {
	out := new(TaskStatusReply)
	err := grpc.Invoke(ctx, "/sonm.Hub/TaskStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hubClient) JoinNetwork(ctx context.Context, in *HubJoinNetworkRequest, opts ...grpc.CallOption) (*NetworkSpec, error) {
	out := new(NetworkSpec)
	err := grpc.Invoke(ctx, "/sonm.Hub/JoinNetwork", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hubClient) TaskLogs(ctx context.Context, in *TaskLogsRequest, opts ...grpc.CallOption) (Hub_TaskLogsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Hub_serviceDesc.Streams[2], c.cc, "/sonm.Hub/TaskLogs", opts...)
	if err != nil {
		return nil, err
	}
	x := &hubTaskLogsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Hub_TaskLogsClient interface {
	Recv() (*TaskLogsChunk, error)
	grpc.ClientStream
}

type hubTaskLogsClient struct {
	grpc.ClientStream
}

func (x *hubTaskLogsClient) Recv() (*TaskLogsChunk, error) {
	m := new(TaskLogsChunk)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *hubClient) GetDealInfo(ctx context.Context, in *ID, opts ...grpc.CallOption) (*DealInfoReply, error) {
	out := new(DealInfoReply)
	err := grpc.Invoke(ctx, "/sonm.Hub/GetDealInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Hub service

type HubServer interface {
	PushTask(Hub_PushTaskServer) error
	PullTask(*PullTaskRequest, Hub_PullTaskServer) error
	// StartTask schedules the task associcated with a deal on some miner.
	StartTask(context.Context, *StartTaskRequest) (*StartTaskReply, error)
	StopTask(context.Context, *ID) (*Empty, error)
	TaskStatus(context.Context, *ID) (*TaskStatusReply, error)
	JoinNetwork(context.Context, *HubJoinNetworkRequest) (*NetworkSpec, error)
	TaskLogs(*TaskLogsRequest, Hub_TaskLogsServer) error
	// Note: currently used for testing pusposes.
	GetDealInfo(context.Context, *ID) (*DealInfoReply, error)
}

func RegisterHubServer(s *grpc.Server, srv HubServer) {
	s.RegisterService(&_Hub_serviceDesc, srv)
}

func _Hub_PushTask_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(HubServer).PushTask(&hubPushTaskServer{stream})
}

type Hub_PushTaskServer interface {
	Send(*Progress) error
	Recv() (*Chunk, error)
	grpc.ServerStream
}

type hubPushTaskServer struct {
	grpc.ServerStream
}

func (x *hubPushTaskServer) Send(m *Progress) error {
	return x.ServerStream.SendMsg(m)
}

func (x *hubPushTaskServer) Recv() (*Chunk, error) {
	m := new(Chunk)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Hub_PullTask_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PullTaskRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(HubServer).PullTask(m, &hubPullTaskServer{stream})
}

type Hub_PullTaskServer interface {
	Send(*Chunk) error
	grpc.ServerStream
}

type hubPullTaskServer struct {
	grpc.ServerStream
}

func (x *hubPullTaskServer) Send(m *Chunk) error {
	return x.ServerStream.SendMsg(m)
}

func _Hub_StartTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HubServer).StartTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.Hub/StartTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HubServer).StartTask(ctx, req.(*StartTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hub_StopTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HubServer).StopTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.Hub/StopTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HubServer).StopTask(ctx, req.(*ID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hub_TaskStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HubServer).TaskStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.Hub/TaskStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HubServer).TaskStatus(ctx, req.(*ID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hub_JoinNetwork_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HubJoinNetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HubServer).JoinNetwork(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.Hub/JoinNetwork",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HubServer).JoinNetwork(ctx, req.(*HubJoinNetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hub_TaskLogs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TaskLogsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(HubServer).TaskLogs(m, &hubTaskLogsServer{stream})
}

type Hub_TaskLogsServer interface {
	Send(*TaskLogsChunk) error
	grpc.ServerStream
}

type hubTaskLogsServer struct {
	grpc.ServerStream
}

func (x *hubTaskLogsServer) Send(m *TaskLogsChunk) error {
	return x.ServerStream.SendMsg(m)
}

func _Hub_GetDealInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HubServer).GetDealInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonm.Hub/GetDealInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HubServer).GetDealInfo(ctx, req.(*ID))
	}
	return interceptor(ctx, in, info, handler)
}

var _Hub_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sonm.Hub",
	HandlerType: (*HubServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StartTask",
			Handler:    _Hub_StartTask_Handler,
		},
		{
			MethodName: "StopTask",
			Handler:    _Hub_StopTask_Handler,
		},
		{
			MethodName: "TaskStatus",
			Handler:    _Hub_TaskStatus_Handler,
		},
		{
			MethodName: "JoinNetwork",
			Handler:    _Hub_JoinNetwork_Handler,
		},
		{
			MethodName: "GetDealInfo",
			Handler:    _Hub_GetDealInfo_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "PushTask",
			Handler:       _Hub_PushTask_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "PullTask",
			Handler:       _Hub_PullTask_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "TaskLogs",
			Handler:       _Hub_TaskLogs_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "hub.proto",
}

// Begin grpccmd
var _ = grpccmd.RunE

// WorkerManagement
var _WorkerManagementCmd = &cobra.Command{
	Use:   "workerManagement [method]",
	Short: "Subcommand for the WorkerManagement service.",
}

var _WorkerManagement_StatusCmd = &cobra.Command{
	Use:   "status",
	Short: "Make the Status method call, input-type: sonm.Empty output-type: sonm.HubStatusReply",
	RunE: grpccmd.RunE(
		"Status",
		"sonm.Empty",
		func(c io.Closer) interface{} {
			cc := c.(*grpc.ClientConn)
			return NewWorkerManagementClient(cc)
		},
	),
}

var _WorkerManagement_StatusCmd_gen = &cobra.Command{
	Use:   "status-gen",
	Short: "Generate JSON for method call of Status (input-type: sonm.Empty)",
	RunE:  grpccmd.TypeToJson("sonm.Empty"),
}

var _WorkerManagement_DevicesCmd = &cobra.Command{
	Use:   "devices",
	Short: "Make the Devices method call, input-type: sonm.Empty output-type: sonm.DevicesReply",
	RunE: grpccmd.RunE(
		"Devices",
		"sonm.Empty",
		func(c io.Closer) interface{} {
			cc := c.(*grpc.ClientConn)
			return NewWorkerManagementClient(cc)
		},
	),
}

var _WorkerManagement_DevicesCmd_gen = &cobra.Command{
	Use:   "devices-gen",
	Short: "Generate JSON for method call of Devices (input-type: sonm.Empty)",
	RunE:  grpccmd.TypeToJson("sonm.Empty"),
}

var _WorkerManagement_FreeDevicesCmd = &cobra.Command{
	Use:   "freeDevices",
	Short: "Make the FreeDevices method call, input-type: sonm.Empty output-type: sonm.DevicesReply",
	RunE: grpccmd.RunE(
		"FreeDevices",
		"sonm.Empty",
		func(c io.Closer) interface{} {
			cc := c.(*grpc.ClientConn)
			return NewWorkerManagementClient(cc)
		},
	),
}

var _WorkerManagement_FreeDevicesCmd_gen = &cobra.Command{
	Use:   "freeDevices-gen",
	Short: "Generate JSON for method call of FreeDevices (input-type: sonm.Empty)",
	RunE:  grpccmd.TypeToJson("sonm.Empty"),
}

var _WorkerManagement_TasksCmd = &cobra.Command{
	Use:   "tasks",
	Short: "Make the Tasks method call, input-type: sonm.Empty output-type: sonm.TaskListReply",
	RunE: grpccmd.RunE(
		"Tasks",
		"sonm.Empty",
		func(c io.Closer) interface{} {
			cc := c.(*grpc.ClientConn)
			return NewWorkerManagementClient(cc)
		},
	),
}

var _WorkerManagement_TasksCmd_gen = &cobra.Command{
	Use:   "tasks-gen",
	Short: "Generate JSON for method call of Tasks (input-type: sonm.Empty)",
	RunE:  grpccmd.TypeToJson("sonm.Empty"),
}

var _WorkerManagement_AskPlansCmd = &cobra.Command{
	Use:   "askPlans",
	Short: "Make the AskPlans method call, input-type: sonm.Empty output-type: sonm.AskPlansReply",
	RunE: grpccmd.RunE(
		"AskPlans",
		"sonm.Empty",
		func(c io.Closer) interface{} {
			cc := c.(*grpc.ClientConn)
			return NewWorkerManagementClient(cc)
		},
	),
}

var _WorkerManagement_AskPlansCmd_gen = &cobra.Command{
	Use:   "askPlans-gen",
	Short: "Generate JSON for method call of AskPlans (input-type: sonm.Empty)",
	RunE:  grpccmd.TypeToJson("sonm.Empty"),
}

var _WorkerManagement_CreateAskPlanCmd = &cobra.Command{
	Use:   "createAskPlan",
	Short: "Make the CreateAskPlan method call, input-type: sonm.AskPlan output-type: sonm.ID",
	RunE: grpccmd.RunE(
		"CreateAskPlan",
		"sonm.AskPlan",
		func(c io.Closer) interface{} {
			cc := c.(*grpc.ClientConn)
			return NewWorkerManagementClient(cc)
		},
	),
}

var _WorkerManagement_CreateAskPlanCmd_gen = &cobra.Command{
	Use:   "createAskPlan-gen",
	Short: "Generate JSON for method call of CreateAskPlan (input-type: sonm.AskPlan)",
	RunE:  grpccmd.TypeToJson("sonm.AskPlan"),
}

var _WorkerManagement_RemoveAskPlanCmd = &cobra.Command{
	Use:   "removeAskPlan",
	Short: "Make the RemoveAskPlan method call, input-type: sonm.ID output-type: sonm.Empty",
	RunE: grpccmd.RunE(
		"RemoveAskPlan",
		"sonm.ID",
		func(c io.Closer) interface{} {
			cc := c.(*grpc.ClientConn)
			return NewWorkerManagementClient(cc)
		},
	),
}

var _WorkerManagement_RemoveAskPlanCmd_gen = &cobra.Command{
	Use:   "removeAskPlan-gen",
	Short: "Generate JSON for method call of RemoveAskPlan (input-type: sonm.ID)",
	RunE:  grpccmd.TypeToJson("sonm.ID"),
}

// Register commands with the root command and service command
func init() {
	grpccmd.RegisterServiceCmd(_WorkerManagementCmd)
	_WorkerManagementCmd.AddCommand(
		_WorkerManagement_StatusCmd,
		_WorkerManagement_StatusCmd_gen,
		_WorkerManagement_DevicesCmd,
		_WorkerManagement_DevicesCmd_gen,
		_WorkerManagement_FreeDevicesCmd,
		_WorkerManagement_FreeDevicesCmd_gen,
		_WorkerManagement_TasksCmd,
		_WorkerManagement_TasksCmd_gen,
		_WorkerManagement_AskPlansCmd,
		_WorkerManagement_AskPlansCmd_gen,
		_WorkerManagement_CreateAskPlanCmd,
		_WorkerManagement_CreateAskPlanCmd_gen,
		_WorkerManagement_RemoveAskPlanCmd,
		_WorkerManagement_RemoveAskPlanCmd_gen,
	)
}

// Hub
var _HubCmd = &cobra.Command{
	Use:   "hub [method]",
	Short: "Subcommand for the Hub service.",
}

var _Hub_PushTaskCmd = &cobra.Command{
	Use:   "pushTask",
	Short: "Make the PushTask method call, input-type: sonm.Chunk output-type: sonm.Progress",
	RunE: grpccmd.RunE(
		"PushTask",
		"sonm.Chunk",
		func(c io.Closer) interface{} {
			cc := c.(*grpc.ClientConn)
			return NewHubClient(cc)
		},
	),
}

var _Hub_PushTaskCmd_gen = &cobra.Command{
	Use:   "pushTask-gen",
	Short: "Generate JSON for method call of PushTask (input-type: sonm.Chunk)",
	RunE:  grpccmd.TypeToJson("sonm.Chunk"),
}

var _Hub_PullTaskCmd = &cobra.Command{
	Use:   "pullTask",
	Short: "Make the PullTask method call, input-type: sonm.PullTaskRequest output-type: sonm.Chunk",
	RunE: grpccmd.RunE(
		"PullTask",
		"sonm.PullTaskRequest",
		func(c io.Closer) interface{} {
			cc := c.(*grpc.ClientConn)
			return NewHubClient(cc)
		},
	),
}

var _Hub_PullTaskCmd_gen = &cobra.Command{
	Use:   "pullTask-gen",
	Short: "Generate JSON for method call of PullTask (input-type: sonm.PullTaskRequest)",
	RunE:  grpccmd.TypeToJson("sonm.PullTaskRequest"),
}

var _Hub_StartTaskCmd = &cobra.Command{
	Use:   "startTask",
	Short: "Make the StartTask method call, input-type: sonm.StartTaskRequest output-type: sonm.StartTaskReply",
	RunE: grpccmd.RunE(
		"StartTask",
		"sonm.StartTaskRequest",
		func(c io.Closer) interface{} {
			cc := c.(*grpc.ClientConn)
			return NewHubClient(cc)
		},
	),
}

var _Hub_StartTaskCmd_gen = &cobra.Command{
	Use:   "startTask-gen",
	Short: "Generate JSON for method call of StartTask (input-type: sonm.StartTaskRequest)",
	RunE:  grpccmd.TypeToJson("sonm.StartTaskRequest"),
}

var _Hub_StopTaskCmd = &cobra.Command{
	Use:   "stopTask",
	Short: "Make the StopTask method call, input-type: sonm.ID output-type: sonm.Empty",
	RunE: grpccmd.RunE(
		"StopTask",
		"sonm.ID",
		func(c io.Closer) interface{} {
			cc := c.(*grpc.ClientConn)
			return NewHubClient(cc)
		},
	),
}

var _Hub_StopTaskCmd_gen = &cobra.Command{
	Use:   "stopTask-gen",
	Short: "Generate JSON for method call of StopTask (input-type: sonm.ID)",
	RunE:  grpccmd.TypeToJson("sonm.ID"),
}

var _Hub_TaskStatusCmd = &cobra.Command{
	Use:   "taskStatus",
	Short: "Make the TaskStatus method call, input-type: sonm.ID output-type: sonm.TaskStatusReply",
	RunE: grpccmd.RunE(
		"TaskStatus",
		"sonm.ID",
		func(c io.Closer) interface{} {
			cc := c.(*grpc.ClientConn)
			return NewHubClient(cc)
		},
	),
}

var _Hub_TaskStatusCmd_gen = &cobra.Command{
	Use:   "taskStatus-gen",
	Short: "Generate JSON for method call of TaskStatus (input-type: sonm.ID)",
	RunE:  grpccmd.TypeToJson("sonm.ID"),
}

var _Hub_JoinNetworkCmd = &cobra.Command{
	Use:   "joinNetwork",
	Short: "Make the JoinNetwork method call, input-type: sonm.HubJoinNetworkRequest output-type: sonm.NetworkSpec",
	RunE: grpccmd.RunE(
		"JoinNetwork",
		"sonm.HubJoinNetworkRequest",
		func(c io.Closer) interface{} {
			cc := c.(*grpc.ClientConn)
			return NewHubClient(cc)
		},
	),
}

var _Hub_JoinNetworkCmd_gen = &cobra.Command{
	Use:   "joinNetwork-gen",
	Short: "Generate JSON for method call of JoinNetwork (input-type: sonm.HubJoinNetworkRequest)",
	RunE:  grpccmd.TypeToJson("sonm.HubJoinNetworkRequest"),
}

var _Hub_TaskLogsCmd = &cobra.Command{
	Use:   "taskLogs",
	Short: "Make the TaskLogs method call, input-type: sonm.TaskLogsRequest output-type: sonm.TaskLogsChunk",
	RunE: grpccmd.RunE(
		"TaskLogs",
		"sonm.TaskLogsRequest",
		func(c io.Closer) interface{} {
			cc := c.(*grpc.ClientConn)
			return NewHubClient(cc)
		},
	),
}

var _Hub_TaskLogsCmd_gen = &cobra.Command{
	Use:   "taskLogs-gen",
	Short: "Generate JSON for method call of TaskLogs (input-type: sonm.TaskLogsRequest)",
	RunE:  grpccmd.TypeToJson("sonm.TaskLogsRequest"),
}

var _Hub_GetDealInfoCmd = &cobra.Command{
	Use:   "getDealInfo",
	Short: "Make the GetDealInfo method call, input-type: sonm.ID output-type: sonm.DealInfoReply",
	RunE: grpccmd.RunE(
		"GetDealInfo",
		"sonm.ID",
		func(c io.Closer) interface{} {
			cc := c.(*grpc.ClientConn)
			return NewHubClient(cc)
		},
	),
}

var _Hub_GetDealInfoCmd_gen = &cobra.Command{
	Use:   "getDealInfo-gen",
	Short: "Generate JSON for method call of GetDealInfo (input-type: sonm.ID)",
	RunE:  grpccmd.TypeToJson("sonm.ID"),
}

// Register commands with the root command and service command
func init() {
	grpccmd.RegisterServiceCmd(_HubCmd)
	_HubCmd.AddCommand(
		_Hub_PushTaskCmd,
		_Hub_PushTaskCmd_gen,
		_Hub_PullTaskCmd,
		_Hub_PullTaskCmd_gen,
		_Hub_StartTaskCmd,
		_Hub_StartTaskCmd_gen,
		_Hub_StopTaskCmd,
		_Hub_StopTaskCmd_gen,
		_Hub_TaskStatusCmd,
		_Hub_TaskStatusCmd_gen,
		_Hub_JoinNetworkCmd,
		_Hub_JoinNetworkCmd_gen,
		_Hub_TaskLogsCmd,
		_Hub_TaskLogsCmd_gen,
		_Hub_GetDealInfoCmd,
		_Hub_GetDealInfoCmd_gen,
	)
}

// End grpccmd

func init() { proto.RegisterFile("hub.proto", fileDescriptor7) }

var fileDescriptor7 = []byte{
	// 1169 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0xcb, 0x8e, 0x1b, 0x45,
	0x14, 0xed, 0xf6, 0xdb, 0xd7, 0xb1, 0xc7, 0xa9, 0x49, 0x46, 0x56, 0xe7, 0xa1, 0xa1, 0xb3, 0xc0,
	0x24, 0xc4, 0x04, 0x93, 0x05, 0x0a, 0x02, 0x64, 0xc6, 0x93, 0x19, 0x27, 0x19, 0x8f, 0x55, 0xc6,
	0x1a, 0x76, 0xa8, 0x6c, 0x57, 0x3c, 0x2d, 0xb7, 0xbb, 0x9b, 0xae, 0x6a, 0xa3, 0xe1, 0x33, 0xd8,
	0x20, 0xb1, 0x66, 0xc1, 0x2f, 0xf0, 0x09, 0xec, 0xf9, 0x00, 0xbe, 0x83, 0x15, 0xaa, 0x47, 0xbf,
	0x66, 0x1c, 0x01, 0x12, 0x3b, 0xdf, 0x73, 0xcf, 0xad, 0xba, 0x75, 0x1f, 0xc7, 0x0d, 0xf5, 0xcb,
	0x68, 0xde, 0x0b, 0x42, 0x9f, 0xfb, 0xa8, 0xc4, 0x7c, 0x6f, 0x63, 0xb5, 0x08, 0x5b, 0x7f, 0x1b,
	0xb8, 0xc4, 0x53, 0xa8, 0x85, 0x16, 0x24, 0x20, 0x73, 0xc7, 0x75, 0xb8, 0x43, 0x99, 0xc6, 0xf6,
	0x16, 0xbe, 0xc7, 0x89, 0xe3, 0xd1, 0x30, 0x06, 0x1c, 0x4f, 0x04, 0x7b, 0x0e, 0xd1, 0xc0, 0xed,
	0x0d, 0x09, 0xd7, 0x94, 0x07, 0x2e, 0x59, 0x50, 0x05, 0xd9, 0x3f, 0x99, 0xd0, 0x9e, 0x72, 0x12,
	0xf2, 0xaf, 0x09, 0x5b, 0x63, 0xfa, 0x5d, 0x44, 0x19, 0x47, 0x0f, 0xa1, 0xb4, 0xa4, 0xc4, 0xed,
	0x98, 0x87, 0x66, 0xb7, 0xd1, 0x87, 0x9e, 0x38, 0xa5, 0x37, 0xa4, 0xc4, 0xc5, 0x12, 0x47, 0x4f,
	0xa1, 0x9e, 0xdc, 0xd5, 0x29, 0x48, 0xd2, 0x9e, 0x22, 0x1d, 0xc5, 0x30, 0x4e, 0x19, 0xe8, 0x39,
	0xd4, 0x43, 0xca, 0xfc, 0x28, 0x5c, 0x50, 0xd6, 0x29, 0x4a, 0xfa, 0x81, 0xa2, 0x0f, 0xd8, 0x7a,
	0xe2, 0x12, 0x0f, 0xc7, 0x5e, 0x9c, 0x12, 0xed, 0x33, 0xb8, 0x7b, 0x1a, 0xcd, 0x5f, 0xf9, 0x8e,
	0x37, 0xa6, 0xfc, 0x7b, 0x3f, 0x4c, 0xb2, 0x3b, 0x80, 0x0a, 0x27, 0x6c, 0x3d, 0x1a, 0xca, 0xfc,
	0xea, 0x58, 0x5b, 0xe8, 0x3e, 0xd4, 0x3d, 0xc5, 0x1c, 0x0d, 0x65, 0x56, 0x75, 0x9c, 0x02, 0xf6,
	0x16, 0x5a, 0x99, 0x77, 0x06, 0xee, 0x15, 0x6a, 0x41, 0xc1, 0x59, 0xea, 0x33, 0x0a, 0xce, 0x12,
	0x59, 0x50, 0xa3, 0xde, 0x32, 0xf0, 0x1d, 0x8f, 0x77, 0x0a, 0x87, 0xc5, 0x6e, 0x1d, 0x27, 0x36,
	0xea, 0x40, 0xf5, 0x32, 0x9a, 0x0f, 0x96, 0xcb, 0x50, 0x3e, 0xa0, 0x8e, 0x63, 0x13, 0x3d, 0x04,
	0x48, 0x2e, 0x61, 0x9d, 0x92, 0x8c, 0xcb, 0x20, 0xf6, 0x9f, 0x26, 0xb4, 0x4e, 0xa3, 0xf9, 0x94,
	0x13, 0x1e, 0x31, 0x75, 0xf1, 0x01, 0x54, 0xa2, 0x80, 0x3b, 0x1b, 0x2a, 0x2f, 0x2f, 0x61, 0x6d,
	0x89, 0x4b, 0xb6, 0x34, 0x64, 0x8e, 0xef, 0xe9, 0xf4, 0x63, 0x53, 0xa4, 0x16, 0xb8, 0x84, 0xbf,
	0xf5, 0xc3, 0x8d, 0xbe, 0x3f, 0xb1, 0x45, 0x14, 0xe5, 0x97, 0x32, 0xb5, 0x92, 0x8a, 0xd2, 0xa6,
	0x28, 0x88, 0x28, 0xcd, 0x91, 0x1f, 0x79, 0xbc, 0x53, 0x3e, 0x34, 0xbb, 0x4d, 0x9c, 0x02, 0xc2,
	0x3b, 0xbc, 0x38, 0x55, 0x79, 0x75, 0x2a, 0xaa, 0x5c, 0x09, 0x80, 0x1e, 0x43, 0x3b, 0xa4, 0xde,
	0x92, 0xfe, 0xb0, 0xf5, 0x23, 0xa6, 0x49, 0x55, 0x49, 0xba, 0x81, 0xdb, 0x3f, 0x9b, 0xd0, 0xd4,
	0x9d, 0xd4, 0x2f, 0xfc, 0x1c, 0x6a, 0x44, 0x03, 0x1d, 0xf3, 0xb0, 0xd8, 0x6d, 0xf4, 0xdf, 0xcb,
	0x35, 0x5c, 0xd1, 0x12, 0xeb, 0xd8, 0xe3, 0xe1, 0x15, 0x4e, 0x42, 0xac, 0x57, 0xe9, 0x79, 0xd2,
	0x85, 0xda, 0x50, 0x5c, 0xd3, 0x2b, 0xdd, 0x2b, 0xf1, 0x13, 0x3d, 0x82, 0xf2, 0x96, 0xb8, 0x11,
	0xd5, 0xe3, 0xd7, 0xcc, 0xcf, 0x93, 0xf2, 0xbd, 0x28, 0x7c, 0x6a, 0xda, 0x3f, 0x9a, 0xd0, 0x14,
	0x3d, 0x7f, 0xe3, 0x30, 0xae, 0x92, 0xfb, 0x18, 0x4a, 0x8e, 0xf7, 0xd6, 0xd7, 0x89, 0x3d, 0x50,
	0x91, 0x39, 0x4a, 0x6f, 0xe4, 0xbd, 0xf5, 0x55, 0x52, 0x92, 0x6a, 0x8d, 0xa1, 0x9e, 0x40, 0x3b,
	0x92, 0x79, 0x92, 0x4f, 0xe6, 0x6e, 0x7a, 0x64, 0xa6, 0xed, 0xd9, 0xa4, 0x7e, 0x33, 0xe1, 0xd6,
	0x90, 0x6e, 0x1d, 0x31, 0xf2, 0x32, 0xa7, 0x7b, 0x50, 0x3c, 0x9a, 0xcc, 0xf4, 0xc2, 0xd5, 0xf5,
	0x2e, 0x4d, 0x66, 0x58, 0xa0, 0xe8, 0x01, 0x94, 0x4e, 0x26, 0x33, 0x26, 0x87, 0x32, 0xf1, 0x9e,
	0x4c, 0x66, 0x58, 0xc2, 0x22, 0x16, 0x0f, 0xce, 0xf4, 0x62, 0x69, 0x2f, 0x1e, 0x9c, 0x61, 0x81,
	0xa2, 0xf7, 0xa1, 0xaa, 0x87, 0x51, 0x4e, 0x47, 0x52, 0xa9, 0x78, 0xa7, 0x62, 0xaf, 0x20, 0x32,
	0xee, 0x87, 0x64, 0x45, 0xe5, 0xa8, 0x24, 0xc4, 0xa9, 0x02, 0x71, 0xec, 0xb5, 0x07, 0xb0, 0x37,
	0x89, 0x5c, 0x37, 0xab, 0x17, 0x07, 0x50, 0x11, 0xba, 0x30, 0x8a, 0xb7, 0x49, 0x5b, 0xc9, 0xa6,
	0x2e, 0xf5, 0x3c, 0x6b, 0xcb, 0xfe, 0xdd, 0x84, 0xa6, 0x90, 0x13, 0x51, 0x53, 0xf5, 0xfe, 0x7f,
	0x52, 0x9c, 0x1e, 0x54, 0xc3, 0xc8, 0xf3, 0x1c, 0x6f, 0xa5, 0x6b, 0x7c, 0x27, 0xce, 0x4e, 0xd4,
	0xf7, 0x8c, 0x04, 0xaa, 0xc4, 0x31, 0x09, 0xf5, 0x85, 0x42, 0x6d, 0x02, 0x97, 0x72, 0xba, 0xd4,
	0x95, 0xd9, 0x1d, 0x91, 0xd2, 0xf2, 0x32, 0x55, 0xfa, 0xb7, 0x32, 0xf5, 0x57, 0x01, 0xf6, 0xae,
	0x75, 0x1a, 0x3d, 0x87, 0x0a, 0x53, 0x2b, 0x23, 0xde, 0xd3, 0xea, 0xdf, 0xdf, 0x39, 0x10, 0x3a,
	0x15, 0xac, 0xb9, 0x62, 0x21, 0x9d, 0x0d, 0x59, 0xd1, 0x31, 0xd9, 0xd0, 0x58, 0xbf, 0x12, 0x00,
	0xdd, 0x81, 0x72, 0xe0, 0x87, 0x9c, 0xe9, 0xfd, 0x57, 0x46, 0x46, 0x4a, 0x4a, 0x39, 0x29, 0xf9,
	0x00, 0xca, 0x11, 0x4b, 0x7b, 0xb9, 0xaf, 0xa7, 0x42, 0x67, 0x3d, 0x13, 0x2e, 0xac, 0x18, 0xe8,
	0x25, 0x20, 0xe2, 0xba, 0xfe, 0x82, 0x70, 0xba, 0x4c, 0x5e, 0x28, 0x05, 0xe1, 0xdd, 0xef, 0xdf,
	0x11, 0x21, 0x74, 0x68, 0x23, 0xe4, 0x7e, 0x34, 0xd4, 0x42, 0x11, 0x9b, 0xf6, 0x37, 0x50, 0xd1,
	0xaa, 0xd2, 0x80, 0xea, 0x6c, 0xfc, 0x7a, 0x7c, 0x7e, 0x31, 0x6e, 0x1b, 0xe8, 0x16, 0xd4, 0xa6,
	0x93, 0xf3, 0xf3, 0x37, 0xa3, 0xf1, 0x49, 0xdb, 0x54, 0xd6, 0xe0, 0x62, 0x2c, 0xac, 0x82, 0x20,
	0xe2, 0xd9, 0x58, 0x1a, 0x45, 0xe1, 0x7a, 0x39, 0x1a, 0x8f, 0xa6, 0xa7, 0xc7, 0xc3, 0x76, 0x09,
	0x01, 0x54, 0xbe, 0xc2, 0xe7, 0xaf, 0x8f, 0xc7, 0xed, 0xb2, 0xfd, 0x8b, 0x29, 0x55, 0x3d, 0xd3,
	0x50, 0xf4, 0x05, 0xd4, 0x54, 0x3d, 0x69, 0x2c, 0x3d, 0xf6, 0xae, 0xc6, 0x6b, 0x93, 0xc6, 0xda,
	0x13, 0xc7, 0x58, 0x18, 0x9a, 0x39, 0xd7, 0xff, 0xb0, 0xee, 0xfd, 0x3f, 0x0a, 0xd0, 0xbe, 0xf0,
	0xc3, 0x35, 0x0d, 0xcf, 0x88, 0x47, 0x56, 0x74, 0x43, 0x3d, 0x8e, 0x9e, 0xa6, 0x55, 0x51, 0x07,
	0x1c, 0x6f, 0x02, 0x7e, 0x65, 0xe9, 0x31, 0xcd, 0xff, 0x65, 0xd8, 0x06, 0xfa, 0x10, 0xaa, 0x5a,
	0x31, 0xf2, 0x7c, 0x14, 0xef, 0x4a, 0xaa, 0x26, 0xb6, 0x81, 0x9e, 0x41, 0xe3, 0x65, 0x48, 0xe9,
	0x7f, 0x88, 0x78, 0x02, 0x65, 0xf1, 0x82, 0x6b, 0xdc, 0xfd, 0x1d, 0xea, 0x68, 0x1b, 0xa8, 0x07,
	0xb5, 0x58, 0xa0, 0x77, 0xf2, 0x73, 0x32, 0x6f, 0x1b, 0xe8, 0x31, 0x34, 0x8f, 0x42, 0x4a, 0x38,
	0xd5, 0x0e, 0x94, 0xd7, 0x6b, 0xab, 0xa6, 0xcc, 0xd1, 0xd0, 0x36, 0x50, 0x17, 0x9a, 0x98, 0x6e,
	0xfc, 0x6d, 0xc2, 0x4d, 0x9c, 0x56, 0xf6, 0x2a, 0xdb, 0xe8, 0xff, 0x5a, 0x84, 0xe2, 0x69, 0x34,
	0x47, 0x4f, 0xa1, 0x36, 0x89, 0xd8, 0xa5, 0x48, 0x32, 0xce, 0xe6, 0xe8, 0x32, 0xf2, 0xd6, 0x56,
	0x4b, 0x19, 0x93, 0xd0, 0x5f, 0x85, 0x94, 0x31, 0xdb, 0xe8, 0x9a, 0xcf, 0x4c, 0xd4, 0x17, 0x74,
	0x25, 0x60, 0x48, 0xf7, 0xee, 0x9a, 0xa0, 0x59, 0xd9, 0x53, 0x6c, 0xe3, 0x99, 0x89, 0x3e, 0x83,
	0x7a, 0xf2, 0xf5, 0x80, 0x0e, 0x92, 0x81, 0xca, 0x7d, 0x36, 0x59, 0x77, 0x6e, 0xe0, 0xea, 0xf5,
	0x8f, 0xa0, 0x36, 0xe5, 0x7e, 0x20, 0x63, 0xdf, 0xf5, 0x18, 0xf4, 0x11, 0x40, 0x3a, 0x41, 0x19,
	0xda, 0xee, 0xe9, 0xb2, 0x0d, 0xf4, 0x25, 0x34, 0x32, 0x1f, 0x47, 0xe8, 0x5e, 0x32, 0x37, 0x37,
	0x3f, 0x99, 0xac, 0xdb, 0x39, 0xd1, 0x9f, 0x06, 0x74, 0x61, 0x1b, 0xe8, 0x05, 0xd4, 0x64, 0x5f,
	0xfd, 0x15, 0x43, 0x99, 0x5b, 0x84, 0x1d, 0xc7, 0xed, 0xe7, 0xe1, 0xb4, 0x1e, 0x3d, 0x68, 0x9c,
	0x50, 0x1e, 0x6b, 0x78, 0x26, 0xdd, 0xfd, 0x54, 0xba, 0x13, 0x75, 0xb7, 0x8d, 0x79, 0x45, 0x7e,
	0x6d, 0x7e, 0xf2, 0x77, 0x00, 0x00, 0x00, 0xff, 0xff, 0x0f, 0xa9, 0x4a, 0x8b, 0xd9, 0x0a, 0x00,
	0x00,
}
